"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var conductor_javascript_exports = {};
__export(conductor_javascript_exports, {
  ApiError: () => ApiError,
  AuthConductorClient: () => AuthConductorClient,
  BaseHttpRequest: () => BaseHttpRequest,
  CancelError: () => CancelError,
  CancelablePromise: () => CancelablePromise,
  ConductorClient: () => ConductorClient,
  ConductorError: () => ConductorError,
  DefaultLogger: () => DefaultLogger,
  DnsCacheResolver: () => DnsCacheResolver,
  EventResourceService: () => EventResourceService,
  HealthCheckResourceService: () => HealthCheckResourceService,
  HumanExecutor: () => HumanExecutor,
  MetadataResourceService: () => MetadataResourceService,
  SchedulerResourceService: () => SchedulerResourceService,
  TaskManager: () => TaskManager,
  TaskResourceService: () => TaskResourceService,
  TaskRunner: () => TaskRunner,
  TaskType: () => TaskType,
  TokenResourceService: () => TokenResourceService,
  WorkflowBulkResourceService: () => WorkflowBulkResourceService,
  WorkflowExecutor: () => WorkflowExecutor,
  WorkflowResourceService: () => WorkflowResourceService,
  baseOrkesConductorClient: () => baseOrkesConductorClient,
  conductorEventTask: () => conductorEventTask,
  doWhileTask: () => doWhileTask,
  dynamicForkTask: () => dynamicForkTask,
  eventTask: () => eventTask,
  fetchCatchDns: () => fetchCatchDns,
  forkTask: () => forkTask,
  forkTaskJoin: () => forkTaskJoin,
  generate: () => generate,
  generateDoWhileTask: () => generateDoWhileTask2,
  generateEventTask: () => generateEventTask,
  generateForkJoinTask: () => generateForkJoinTask2,
  generateHTTPTask: () => generateHTTPTask,
  generateInlineTask: () => generateInlineTask,
  generateJQTransformTask: () => generateJQTransformTask,
  generateJoinTask: () => generateJoinTask,
  generateKafkaPublishTask: () => generateKafkaPublishTask,
  generateSetVariableTask: () => generateSetVariableTask,
  generateSimpleTask: () => generateSimpleTask,
  generateSubWorkflowTask: () => generateSubWorkflowTask,
  generateSwitchTask: () => generateSwitchTask2,
  generateTerminateTask: () => generateTerminateTask,
  generateWaitTask: () => generateWaitTask,
  httpTask: () => httpTask,
  inlineTask: () => inlineTask,
  joinTask: () => joinTask,
  jsonJqTask: () => jsonJqTask,
  kafkaPublishTask: () => kafkaPublishTask,
  newLoopTask: () => newLoopTask,
  noopErrorHandler: () => noopErrorHandler,
  noopLogger: () => noopLogger,
  orkesConductorClient: () => orkesConductorClient,
  request: () => request2,
  setVariableTask: () => setVariableTask,
  simpleTask: () => simpleTask,
  sqsEventTask: () => sqsEventTask,
  subWorkflowTask: () => subWorkflowTask,
  switchTask: () => switchTask,
  taskGenMapper: () => taskGenMapper,
  terminateTask: () => terminateTask,
  toMaybeUrl: () => toMaybeUrl,
  waitTaskDuration: () => waitTaskDuration,
  waitTaskUntil: () => waitTaskUntil,
  workflow: () => workflow
});
module.exports = __toCommonJS(conductor_javascript_exports);

// src/common/ConductorLogger.ts
var LOG_LEVELS = {
  DEBUG: 10,
  INFO: 30,
  ERROR: 60
};
var DefaultLogger = class {
  constructor(config = {}) {
    this.info = (...args) => {
      this.log("INFO", ...args);
    };
    this.debug = (...args) => {
      this.log("DEBUG", ...args);
    };
    this.error = (...args) => {
      this.log("ERROR", ...args);
    };
    const { level, tags = [] } = config;
    this.tags = tags;
    if (level && level in LOG_LEVELS) {
      this.level = LOG_LEVELS[level];
    } else {
      this.level = LOG_LEVELS.INFO;
    }
  }
  log(level, ...args) {
    let resolvedLevel;
    let name = level;
    if (level in LOG_LEVELS) {
      resolvedLevel = LOG_LEVELS[level];
    } else {
      name = "INFO";
      resolvedLevel = LOG_LEVELS.INFO;
    }
    if (resolvedLevel >= this.level) {
      console.log(name, ...this.tags, ...args);
    }
  }
};
var noopLogger = {
  //eslint-disable-next-line
  debug: (...args) => {
  },
  //eslint-disable-next-line
  info: (...args) => {
  },
  //eslint-disable-next-line
  error: (...args) => {
  }
};

// src/common/types.ts
var TaskType = /* @__PURE__ */ ((TaskType2) => {
  TaskType2["START"] = "START";
  TaskType2["SIMPLE"] = "SIMPLE";
  TaskType2["DYNAMIC"] = "DYNAMIC";
  TaskType2["FORK_JOIN"] = "FORK_JOIN";
  TaskType2["FORK_JOIN_DYNAMIC"] = "FORK_JOIN_DYNAMIC";
  TaskType2["DECISION"] = "DECISION";
  TaskType2["SWITCH"] = "SWITCH";
  TaskType2["JOIN"] = "JOIN";
  TaskType2["DO_WHILE"] = "DO_WHILE";
  TaskType2["SUB_WORKFLOW"] = "SUB_WORKFLOW";
  TaskType2["EVENT"] = "EVENT";
  TaskType2["WAIT"] = "WAIT";
  TaskType2["USER_DEFINED"] = "USER_DEFINED";
  TaskType2["HTTP"] = "HTTP";
  TaskType2["LAMBDA"] = "LAMBDA";
  TaskType2["INLINE"] = "INLINE";
  TaskType2["EXCLUSIVE_JOIN"] = "EXCLUSIVE_JOIN";
  TaskType2["TERMINAL"] = "TERMINAL";
  TaskType2["TERMINATE"] = "TERMINATE";
  TaskType2["KAFKA_PUBLISH"] = "KAFKA_PUBLISH";
  TaskType2["JSON_JQ_TRANSFORM"] = "JSON_JQ_TRANSFORM";
  TaskType2["SET_VARIABLE"] = "SET_VARIABLE";
  return TaskType2;
})(TaskType || {});

// src/common/open-api/services/EventResourceService.ts
var EventResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Get queue config by name
   * @param queueType
   * @param queueName
   * @returns any OK
   * @throws ApiError
   */
  getQueueConfig(queueType, queueName) {
    return this.httpRequest.request({
      method: "GET",
      url: "/event/queue/config/{queueType}/{queueName}",
      path: {
        "queueType": queueType,
        "queueName": queueName
      }
    });
  }
  /**
   * Create or update queue config by name
   * @param queueType
   * @param queueName
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  putQueueConfig(queueType, queueName, requestBody) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/event/queue/config/{queueType}/{queueName}",
      path: {
        "queueType": queueType,
        "queueName": queueName
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Delete queue config by name
   * @param queueType
   * @param queueName
   * @returns any OK
   * @throws ApiError
   */
  deleteQueueConfig(queueType, queueName) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/event/queue/config/{queueType}/{queueName}",
      path: {
        "queueType": queueType,
        "queueName": queueName
      }
    });
  }
  /**
   * Get all the event handlers
   * @returns EventHandler OK
   * @throws ApiError
   */
  getEventHandlers() {
    return this.httpRequest.request({
      method: "GET",
      url: "/event"
    });
  }
  /**
   * Update an existing event handler.
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  updateEventHandler(requestBody) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/event",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Add a new event handler.
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  addEventHandler(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/event",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get all queue configs
   * @returns any OK
   * @throws ApiError
   */
  getQueueNames() {
    return this.httpRequest.request({
      method: "GET",
      url: "/event/queue/config"
    });
  }
  /**
   * Remove an event handler
   * @param name
   * @returns any OK
   * @throws ApiError
   */
  removeEventHandlerStatus(name) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/event/{name}",
      path: {
        "name": name
      }
    });
  }
  /**
   * Get event handlers for a given event
   * @param event
   * @param activeOnly
   * @returns EventHandler OK
   * @throws ApiError
   */
  getEventHandlersForEvent(event, activeOnly = true) {
    return this.httpRequest.request({
      method: "GET",
      url: "/event/{event}",
      path: {
        "event": event
      },
      query: {
        "activeOnly": activeOnly
      }
    });
  }
};

// src/common/open-api/services/HealthCheckResourceService.ts
var HealthCheckResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * @returns any OK
   * @throws ApiError
   */
  doCheck() {
    return this.httpRequest.request({
      method: "GET",
      url: "/health"
    });
  }
};

// src/common/open-api/services/MetadataResourceService.ts
var MetadataResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Gets the task definition
   * @param tasktype
   * @param metadata
   * @returns TaskDef OK
   * @throws ApiError
   */
  getTaskDef(tasktype, metadata = false) {
    return this.httpRequest.request({
      method: "GET",
      url: "/metadata/taskdefs/{tasktype}",
      path: {
        "tasktype": tasktype
      },
      query: {
        "metadata": metadata
      }
    });
  }
  /**
   * Remove a task definition
   * @param tasktype
   * @returns any OK
   * @throws ApiError
   */
  unregisterTaskDef(tasktype) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/metadata/taskdefs/{tasktype}",
      path: {
        "tasktype": tasktype
      }
    });
  }
  /**
   * Retrieves all workflow definition along with blueprint
   * @param access
   * @param metadata
   * @param tagKey
   * @param tagValue
   * @returns WorkflowDef OK
   * @throws ApiError
   */
  getAllWorkflows(access = "READ", metadata = false, tagKey, tagValue) {
    return this.httpRequest.request({
      method: "GET",
      url: "/metadata/workflow",
      query: {
        "access": access,
        "metadata": metadata,
        "tagKey": tagKey,
        "tagValue": tagValue
      }
    });
  }
  /**
   * Create or update workflow definition(s)
   * @param requestBody
   * @param overwrite
   * @returns any OK
   * @throws ApiError
   */
  update(requestBody, overwrite = true) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/metadata/workflow",
      query: {
        "overwrite": overwrite
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Create a new workflow definition
   * @param requestBody
   * @param overwrite
   * @returns any OK
   * @throws ApiError
   */
  create(requestBody, overwrite = false) {
    return this.httpRequest.request({
      method: "POST",
      url: "/metadata/workflow",
      query: {
        "overwrite": overwrite
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Gets all task definition
   * @param access
   * @param metadata
   * @param tagKey
   * @param tagValue
   * @returns TaskDef OK
   * @throws ApiError
   */
  getTaskDefs(access = "READ", metadata = false, tagKey, tagValue) {
    return this.httpRequest.request({
      method: "GET",
      url: "/metadata/taskdefs",
      query: {
        "access": access,
        "metadata": metadata,
        "tagKey": tagKey,
        "tagValue": tagValue
      }
    });
  }
  /**
   * Update an existing task
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  updateTaskDef(requestBody) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/metadata/taskdefs",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Create or update task definition(s)
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  registerTaskDef(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/metadata/taskdefs",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Removes workflow definition. It does not remove workflows associated with the definition.
   * @param name
   * @param version
   * @returns any OK
   * @throws ApiError
   */
  unregisterWorkflowDef(name, version) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/metadata/workflow/{name}/{version}",
      path: {
        "name": name,
        "version": version
      }
    });
  }
  /**
   * Retrieves workflow definition along with blueprint
   * @param name
   * @param version
   * @param metadata
   * @returns WorkflowDef OK
   * @throws ApiError
   */
  get(name, version, metadata = false) {
    return this.httpRequest.request({
      method: "GET",
      url: "/metadata/workflow/{name}",
      path: {
        "name": name
      },
      query: {
        "version": version,
        "metadata": metadata
      }
    });
  }
};

// src/common/open-api/services/SchedulerResourceService.ts
var SchedulerResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Get an existing workflow schedule by name
   * @param name
   * @returns any OK
   * @throws ApiError
   */
  getSchedule(name) {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/schedules/{name}",
      path: {
        "name": name
      }
    });
  }
  /**
   * Deletes an existing workflow schedule by name
   * @param name
   * @returns any OK
   * @throws ApiError
   */
  deleteSchedule(name) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/scheduler/schedules/{name}",
      path: {
        "name": name
      }
    });
  }
  /**
   * Get list of the next x (default 3, max 5) execution times for a scheduler
   * @param cronExpression
   * @param scheduleStartTime
   * @param scheduleEndTime
   * @param limit
   * @returns number OK
   * @throws ApiError
   */
  getNextFewSchedules(cronExpression, scheduleStartTime, scheduleEndTime, limit = 3) {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/nextFewSchedules",
      query: {
        "cronExpression": cronExpression,
        "scheduleStartTime": scheduleStartTime,
        "scheduleEndTime": scheduleEndTime,
        "limit": limit
      }
    });
  }
  /**
   * Pauses an existing schedule by name
   * @param name
   * @returns any OK
   * @throws ApiError
   */
  pauseSchedule(name) {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/schedules/{name}/pause",
      path: {
        "name": name
      }
    });
  }
  /**
   * Pause all scheduling in a single conductor server instance (for debugging only)
   * @returns any OK
   * @throws ApiError
   */
  pauseAllSchedules() {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/admin/pause"
    });
  }
  /**
   * Resume a paused schedule by name
   * @param name
   * @returns any OK
   * @throws ApiError
   */
  resumeSchedule(name) {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/schedules/{name}/resume",
      path: {
        "name": name
      }
    });
  }
  /**
   * Requeue all execution records
   * @returns any OK
   * @throws ApiError
   */
  requeueAllExecutionRecords() {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/admin/requeue"
    });
  }
  /**
   * Resume all scheduling
   * @returns any OK
   * @throws ApiError
   */
  resumeAllSchedules() {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/admin/resume"
    });
  }
  /**
   * Get all existing workflow schedules and optionally filter by workflow name
   * @param workflowName
   * @returns WorkflowSchedule OK
   * @throws ApiError
   */
  getAllSchedules(workflowName) {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/schedules",
      query: {
        "workflowName": workflowName
      }
    });
  }
  /**
   * Create or update a schedule for a specified workflow with a corresponding start workflow request
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  saveSchedule(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/scheduler/schedules",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Test timeout - do not use in production
   * @returns any OK
   * @throws ApiError
   */
  testTimeout() {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/test/timeout"
    });
  }
  /**
   * Search for workflows based on payload and other parameters
   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
   * @param start
   * @param size
   * @param sort
   * @param freeText
   * @param query
   * @returns SearchResultWorkflowScheduleExecutionModel OK
   * @throws ApiError
   */
  searchV21(start, size = 100, sort, freeText = "*", query) {
    return this.httpRequest.request({
      method: "GET",
      url: "/scheduler/search/executions",
      query: {
        "start": start,
        "size": size,
        "sort": sort,
        "freeText": freeText,
        "query": query
      }
    });
  }
};

// src/common/open-api/services/TaskResourceService.ts
var TaskResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Poll for a task of a certain type
   * @param tasktype
   * @param workerid
   * @param domain
   * @returns Task OK
   * @throws ApiError
   */
  poll(tasktype, workerid, domain) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/poll/{tasktype}",
      path: {
        "tasktype": tasktype
      },
      query: {
        "workerid": workerid,
        "domain": domain
      }
    });
  }
  /**
   * Get the details about each queue
   * @returns number OK
   * @throws ApiError
   */
  allVerbose() {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/queue/all/verbose"
    });
  }
  /**
   * Update a task By Ref Name
   * @param workflowId
   * @param taskRefName
   * @param status
   * @param requestBody
   * @returns string OK
   * @throws ApiError
   */
  updateTask(workflowId, taskRefName, status, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/tasks/{workflowId}/{taskRefName}/{status}",
      path: {
        "workflowId": workflowId,
        "taskRefName": taskRefName,
        "status": status
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get task by Id
   * @param taskId
   * @returns Task OK
   * @throws ApiError
   */
  getTask(taskId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/{taskId}",
      path: {
        "taskId": taskId
      }
    });
  }
  /**
   * Get the details about each queue
   * @returns number OK
   * @throws ApiError
   */
  all() {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/queue/all"
    });
  }
  /**
   * Requeue pending tasks
   * @param taskType
   * @returns string OK
   * @throws ApiError
   */
  requeuePendingTask(taskType) {
    return this.httpRequest.request({
      method: "POST",
      url: "/tasks/queue/requeue/{taskType}",
      path: {
        "taskType": taskType
      }
    });
  }
  /**
   * Search for tasks based in payload and other parameters
   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
   * @param start
   * @param size
   * @param sort
   * @param freeText
   * @param query
   * @returns SearchResultTaskSummary OK
   * @throws ApiError
   */
  search(start, size = 100, sort, freeText = "*", query) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/search",
      query: {
        "start": start,
        "size": size,
        "sort": sort,
        "freeText": freeText,
        "query": query
      }
    });
  }
  /**
   * Search for tasks based in payload and other parameters
   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
   * @param start
   * @param size
   * @param sort
   * @param freeText
   * @param query
   * @returns SearchResultTask OK
   * @throws ApiError
   */
  searchV22(start, size = 100, sort, freeText = "*", query) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/search-v2",
      query: {
        "start": start,
        "size": size,
        "sort": sort,
        "freeText": freeText,
        "query": query
      }
    });
  }
  /**
   * Get the last poll data for a given task type
   * @param taskType
   * @returns PollData OK
   * @throws ApiError
   */
  getPollData(taskType) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/queue/polldata",
      query: {
        "taskType": taskType
      }
    });
  }
  /**
   * Get Task Execution Logs
   * @param taskId
   * @returns TaskExecLog OK
   * @throws ApiError
   */
  getTaskLogs(taskId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/{taskId}/log",
      path: {
        "taskId": taskId
      }
    });
  }
  /**
   * Log Task Execution Details
   * @param taskId
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  log(taskId, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/tasks/{taskId}/log",
      path: {
        "taskId": taskId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get the last poll data for all task types
   * @returns PollData OK
   * @throws ApiError
   */
  getAllPollData() {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/queue/polldata/all"
    });
  }
  /**
   * Batch poll for a task of a certain type
   * @param tasktype
   * @param workerid
   * @param domain
   * @param count
   * @param timeout
   * @returns Task OK
   * @throws ApiError
   */
  batchPoll(tasktype, workerid, domain, count = 1, timeout = 100) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/poll/batch/{tasktype}",
      path: {
        "tasktype": tasktype
      },
      query: {
        "workerid": workerid,
        "domain": domain,
        "count": count,
        "timeout": timeout
      }
    });
  }
  /**
   * Update a task
   * @param requestBody
   * @returns string OK
   * @throws ApiError
   */
  updateTask1(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/tasks",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get Task type queue sizes
   * @param taskType
   * @returns number OK
   * @throws ApiError
   */
  size1(taskType) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/queue/sizes",
      query: {
        "taskType": taskType
      }
    });
  }
  /**
   * Get the external uri where the task payload is to be stored
   * @param path
   * @param operation
   * @param payloadType
   * @returns ExternalStorageLocation OK
   * @throws ApiError
   */
  getExternalStorageLocation1(path, operation, payloadType) {
    return this.httpRequest.request({
      method: "GET",
      url: "/tasks/externalstoragelocation",
      query: {
        "path": path,
        "operation": operation,
        "payloadType": payloadType
      }
    });
  }
};

// src/common/open-api/services/TokenResourceService.ts
var TokenResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Generate JWT with the given access key
   * @param requestBody
   * @returns Response OK
   * @throws ApiError
   */
  generateToken(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/token",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Get the user info from the token
   * @returns any OK
   * @throws ApiError
   */
  getUserInfo() {
    return this.httpRequest.request({
      method: "GET",
      url: "/token/userInfo"
    });
  }
};

// src/common/open-api/services/WorkflowBulkResourceService.ts
var WorkflowBulkResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Retry the last failed task for each workflow from the list
   * @param requestBody
   * @returns BulkResponse OK
   * @throws ApiError
   */
  retry(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/bulk/retry",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Restart the list of completed workflow
   * @param requestBody
   * @param useLatestDefinitions
   * @returns BulkResponse OK
   * @throws ApiError
   */
  restart(requestBody, useLatestDefinitions = false) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/bulk/restart",
      query: {
        "useLatestDefinitions": useLatestDefinitions
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Terminate workflows execution
   * @param requestBody
   * @param reason
   * @returns BulkResponse OK
   * @throws ApiError
   */
  terminate(requestBody, reason) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/bulk/terminate",
      query: {
        "reason": reason
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Resume the list of workflows
   * @param requestBody
   * @returns BulkResponse OK
   * @throws ApiError
   */
  resumeWorkflow(requestBody) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/workflow/bulk/resume",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Pause the list of workflows
   * @param requestBody
   * @returns BulkResponse OK
   * @throws ApiError
   */
  pauseWorkflow1(requestBody) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/workflow/bulk/pause",
      body: requestBody,
      mediaType: "application/json"
    });
  }
};

// src/common/open-api/services/WorkflowResourceService.ts
var WorkflowResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Retrieve all the running workflows
   * @param name
   * @param version
   * @param startTime
   * @param endTime
   * @returns string OK
   * @throws ApiError
   */
  getRunningWorkflow(name, version = 1, startTime, endTime) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/running/{name}",
      path: {
        "name": name
      },
      query: {
        "version": version,
        "startTime": startTime,
        "endTime": endTime
      }
    });
  }
  /**
   * Execute a workflow synchronously
   * @param body 
   * @param name 
   * @param version 
   * @param requestId 
   * @param waitUntilTaskRef 
   * @param callback 
   * @returns workflowRun
   * @throws ApiError
   */
  executeWorkflow(body, name, version, requestId, waitUntilTaskRef) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/execute/{name}/{version}",
      path: {
        "name": name,
        "version": version
      },
      query: {
        "requestId": requestId,
        "waitUntilTaskRef": waitUntilTaskRef
      },
      body,
      mediaType: "application/json"
    });
  }
  /**
   * Start a new workflow with StartWorkflowRequest, which allows task to be executed in a domain
   * @param requestBody
   * @returns string OK
   * @throws ApiError
   */
  startWorkflow(requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow",
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Starts the decision task for a workflow
   * @param workflowId
   * @returns any OK
   * @throws ApiError
   */
  decide(workflowId) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/workflow/decide/{workflowId}",
      path: {
        "workflowId": workflowId
      }
    });
  }
  /**
   * Reruns the workflow from a specific task
   * @param workflowId
   * @param requestBody
   * @returns string OK
   * @throws ApiError
   */
  rerun(workflowId, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/{workflowId}/rerun",
      path: {
        "workflowId": workflowId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Search for workflows based on payload and other parameters
   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
   * @param start
   * @param size
   * @param sort
   * @param freeText
   * @param query
   * @returns SearchResultWorkflow OK
   * @throws ApiError
   */
  searchV21(start, size = 100, sort, freeText = "*", query) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/search-v2",
      query: {
        "start": start,
        "size": size,
        "sort": sort,
        "freeText": freeText,
        "query": query
      }
    });
  }
  /**
   * Pauses the workflow
   * @param workflowId
   * @returns any OK
   * @throws ApiError
   */
  pauseWorkflow(workflowId) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/workflow/{workflowId}/pause",
      path: {
        "workflowId": workflowId
      }
    });
  }
  /**
   * Skips a given task from a current running workflow
   * @param workflowId
   * @param taskReferenceName
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  skipTaskFromWorkflow(workflowId, taskReferenceName, requestBody) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/workflow/{workflowId}/skiptask/{taskReferenceName}",
      path: {
        "workflowId": workflowId,
        "taskReferenceName": taskReferenceName
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Lists workflows for the given correlation id list
   * @param name
   * @param requestBody
   * @param includeClosed
   * @param includeTasks
   * @returns Workflow OK
   * @throws ApiError
   */
  getWorkflows(name, requestBody, includeClosed = false, includeTasks = false) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/{name}/correlated",
      path: {
        "name": name
      },
      query: {
        "includeClosed": includeClosed,
        "includeTasks": includeTasks
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Gets the workflow by workflow id
   * @param workflowId
   * @param includeOutput
   * @param includeVariables
   * @returns WorkflowStatus OK
   * @throws ApiError
   */
  getWorkflowStatusSummary(workflowId, includeOutput = false, includeVariables = false) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/{workflowId}/status",
      path: {
        "workflowId": workflowId
      },
      query: {
        "includeOutput": includeOutput,
        "includeVariables": includeVariables
      }
    });
  }
  /**
   * Lists workflows for the given correlation id
   * @param name
   * @param correlationId
   * @param includeClosed
   * @param includeTasks
   * @returns Workflow OK
   * @throws ApiError
   */
  getWorkflows1(name, correlationId, includeClosed = false, includeTasks = false) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/{name}/correlated/{correlationId}",
      path: {
        "name": name,
        "correlationId": correlationId
      },
      query: {
        "includeClosed": includeClosed,
        "includeTasks": includeTasks
      }
    });
  }
  /**
   * Retries the last failed task
   * @param workflowId
   * @param resumeSubworkflowTasks
   * @returns void
   * @throws ApiError
   */
  retry1(workflowId, resumeSubworkflowTasks = false) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/{workflowId}/retry",
      path: {
        "workflowId": workflowId
      },
      query: {
        "resumeSubworkflowTasks": resumeSubworkflowTasks
      }
    });
  }
  /**
   * Gets the workflow by workflow id
   * @param workflowId
   * @param includeTasks
   * @returns Workflow OK
   * @throws ApiError
   */
  getExecutionStatus(workflowId, includeTasks = true) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/{workflowId}",
      path: {
        "workflowId": workflowId
      },
      query: {
        "includeTasks": includeTasks
      }
    });
  }
  /**
   * Terminate workflow execution
   * @param workflowId
   * @param reason
   * @returns any OK
   * @throws ApiError
   */
  terminate1(workflowId, reason) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/workflow/{workflowId}",
      path: {
        "workflowId": workflowId
      },
      query: {
        "reason": reason
      }
    });
  }
  /**
   * Resumes the workflow
   * @param workflowId
   * @returns any OK
   * @throws ApiError
   */
  resumeWorkflow(workflowId) {
    return this.httpRequest.request({
      method: "PUT",
      url: "/workflow/{workflowId}/resume",
      path: {
        "workflowId": workflowId
      }
    });
  }
  /**
   * Removes the workflow from the system
   * @param workflowId
   * @param archiveWorkflow
   * @returns any OK
   * @throws ApiError
   */
  delete(workflowId, archiveWorkflow = true) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/workflow/{workflowId}/remove",
      path: {
        "workflowId": workflowId
      },
      query: {
        "archiveWorkflow": archiveWorkflow
      }
    });
  }
  /**
   * Search for workflows based on task parameters
   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
   * @param start
   * @param size
   * @param sort
   * @param freeText
   * @param query
   * @returns SearchResultWorkflowSummary OK
   * @throws ApiError
   */
  searchWorkflowsByTasks(start, size = 100, sort, freeText = "*", query) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/search-by-tasks",
      query: {
        "start": start,
        "size": size,
        "sort": sort,
        "freeText": freeText,
        "query": query
      }
    });
  }
  /**
   * Get the uri and path of the external storage where the workflow payload is to be stored
   * @param path
   * @param operation
   * @param payloadType
   * @returns ExternalStorageLocation OK
   * @throws ApiError
   */
  getExternalStorageLocation(path, operation, payloadType) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/externalstoragelocation",
      query: {
        "path": path,
        "operation": operation,
        "payloadType": payloadType
      }
    });
  }
  /**
   * Start a new workflow. Returns the ID of the workflow instance that can be later used for tracking
   * @param name
   * @param requestBody
   * @param version
   * @param correlationId
   * @param priority
   * @returns string OK
   * @throws ApiError
   */
  startWorkflow1(name, requestBody, version, correlationId, priority) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/{name}",
      path: {
        "name": name
      },
      query: {
        "version": version,
        "correlationId": correlationId,
        "priority": priority
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Restarts a completed workflow
   * @param workflowId
   * @param useLatestDefinitions
   * @returns void
   * @throws ApiError
   */
  restart1(workflowId, useLatestDefinitions = false) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/{workflowId}/restart",
      path: {
        "workflowId": workflowId
      },
      query: {
        "useLatestDefinitions": useLatestDefinitions
      }
    });
  }
  /**
   * Search for workflows based on payload and other parameters
   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
   * @param queryId
   * @param start
   * @param size
   * @param sort
   * @param freeText
   * @param query
   * @param skipCache
   * @returns ScrollableSearchResultWorkflowSummary OK
   * @throws ApiError
   */
  search1(queryId, start, size = 100, sort, freeText = "*", query, skipCache = false) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/search",
      query: {
        "queryId": queryId,
        "start": start,
        "size": size,
        "sort": sort,
        "freeText": freeText,
        "query": query,
        "skipCache": skipCache
      }
    });
  }
  /**
   * Search for workflows based on task parameters
   * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
   * @param start
   * @param size
   * @param sort
   * @param freeText
   * @param query
   * @returns SearchResultWorkflow OK
   * @throws ApiError
   */
  searchWorkflowsByTasksV2(start, size = 100, sort, freeText = "*", query) {
    return this.httpRequest.request({
      method: "GET",
      url: "/workflow/search-by-tasks-v2",
      query: {
        "start": start,
        "size": size,
        "sort": sort,
        "freeText": freeText,
        "query": query
      }
    });
  }
  /**
   * Resets callback times of all non-terminal SIMPLE tasks to 0
   * @param workflowId
   * @returns void
   * @throws ApiError
   */
  resetWorkflow(workflowId) {
    return this.httpRequest.request({
      method: "POST",
      url: "/workflow/{workflowId}/resetcallbacks",
      path: {
        "workflowId": workflowId
      }
    });
  }
};

// src/common/open-api/core/ApiError.ts
var ApiError = class extends Error {
  constructor(request3, response, message) {
    super(message);
    this.name = "ApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.body = response.body;
    this.request = request3;
  }
};

// src/common/open-api/core/CancelablePromise.ts
var CancelError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CancelError";
  }
  get isCancelled() {
    return true;
  }
};
var CancelablePromise = class {
  static {
    Symbol.toStringTag;
  }
  constructor(executor) {
    this._isResolved = false;
    this._isRejected = false;
    this._isCancelled = false;
    this._cancelHandlers = [];
    this._promise = new Promise((resolve3, reject) => {
      this._resolve = resolve3;
      this._reject = reject;
      const onResolve = (value) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isResolved = true;
        this._resolve?.(value);
      };
      const onReject = (reason) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._isRejected = true;
        this._reject?.(reason);
      };
      const onCancel = (cancelHandler) => {
        if (this._isResolved || this._isRejected || this._isCancelled) {
          return;
        }
        this._cancelHandlers.push(cancelHandler);
      };
      Object.defineProperty(onCancel, "isResolved", {
        get: () => this._isResolved
      });
      Object.defineProperty(onCancel, "isRejected", {
        get: () => this._isRejected
      });
      Object.defineProperty(onCancel, "isCancelled", {
        get: () => this._isCancelled
      });
      return executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel() {
    if (this._isResolved || this._isRejected || this._isCancelled) {
      return;
    }
    this._isCancelled = true;
    if (this._cancelHandlers.length) {
      try {
        for (const cancelHandler of this._cancelHandlers) {
          cancelHandler();
        }
      } catch (error) {
        console.warn("Cancellation threw an error", error);
        return;
      }
    }
    this._cancelHandlers.length = 0;
    this._reject?.(new CancelError("Request aborted"));
  }
  get isCancelled() {
    return this._isCancelled;
  }
};

// src/common/open-api/core/request.ts
var isDefined = (value) => {
  return value !== void 0 && value !== null;
};
var isString = (value) => {
  return typeof value === "string";
};
var isStringWithValue = (value) => {
  return isString(value) && value !== "";
};
var isBlob = (value) => {
  return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
var isFormData = (value) => {
  return value instanceof FormData;
};
var base64 = (str) => {
  try {
    return btoa(str);
  } catch (err) {
    return Buffer.from(str).toString("base64");
  }
};
var getQueryString = (params) => {
  const qs = [];
  const append = (key, value) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };
  const process = (key, value) => {
    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach((v) => {
          process(key, v);
        });
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([k, v]) => {
          process(`${key}[${k}]`, v);
        });
      } else {
        append(key, value);
      }
    }
  };
  Object.entries(params).forEach(([key, value]) => {
    process(key, value);
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
};
var getUrl = (config, options) => {
  const encoder = config.ENCODE_PATH || encodeURI;
  const path = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {
    if (options.path?.hasOwnProperty(group)) {
      return encoder(String(options.path[group]));
    }
    return substring;
  });
  const url = `${config.BASE}${path}`;
  if (options.query) {
    return `${url}${getQueryString(options.query)}`;
  }
  return url;
};
var getFormData = (options) => {
  if (options.formData) {
    const formData = new FormData();
    const process = (key, value) => {
      if (isString(value) || isBlob(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };
    Object.entries(options.formData).filter(([_, value]) => isDefined(value)).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => process(key, v));
      } else {
        process(key, value);
      }
    });
    return formData;
  }
  return void 0;
};
var resolve = async (options, resolver) => {
  if (typeof resolver === "function") {
    return resolver(options);
  }
  return resolver;
};
var getHeaders = async (config, options) => {
  const token = await resolve(options, config.TOKEN);
  const username = await resolve(options, config.USERNAME);
  const password = await resolve(options, config.PASSWORD);
  const additionalHeaders = await resolve(options, config.HEADERS);
  const headers = Object.entries({
    Accept: "application/json",
    ...additionalHeaders,
    ...options.headers
  }).filter(([_, value]) => isDefined(value)).reduce(
    (headers2, [key, value]) => ({
      ...headers2,
      [key]: String(value)
    }),
    {}
  );
  if (isStringWithValue(token)) {
    headers["X-AUTHORIZATION"] = token;
  }
  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = base64(`${username}:${password}`);
    headers["Authorization"] = `Basic ${credentials}`;
  }
  if (options.body) {
    if (options.mediaType) {
      headers["Content-Type"] = options.mediaType;
    } else if (isBlob(options.body)) {
      headers["Content-Type"] = "application/octet-stream";
    } else if (isString(options.body)) {
      headers["Content-Type"] = "text/plain";
    } else if (!isFormData(options.body)) {
      headers["Content-Type"] = "application/json";
    }
  }
  return new Headers(headers);
};
var getRequestBody = (options) => {
  if (options.body) {
    if (options.mediaType?.includes("/json")) {
      return JSON.stringify(options.body);
    } else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {
      return options.body;
    } else {
      return JSON.stringify(options.body);
    }
  }
  return void 0;
};
var sendRequest = async (options, url, body, formData, headers, onCancel) => {
  const controller = new AbortController();
  const request3 = {
    headers,
    method: options.method,
    body: body ?? formData,
    signal: controller.signal
  };
  onCancel(() => controller.abort());
  return await fetch(url, request3);
};
var getResponseHeader = (response, responseHeader) => {
  if (responseHeader) {
    const content = response.headers.get(responseHeader);
    if (isString(content)) {
      return content;
    }
  }
  return void 0;
};
var getResponseBody = async (response) => {
  if (response.status !== 204) {
    try {
      const contentType = response.headers.get("Content-Type");
      if (contentType) {
        const isJSON = contentType.toLowerCase().startsWith("application/json");
        if (isJSON) {
          return await response.json();
        } else {
          return await response.text();
        }
      }
    } catch (error) {
      console.error(error);
    }
  }
  return void 0;
};
var catchErrorCodes = (options, result) => {
  const errors = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
    ...options.errors
  };
  const error = errors[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }
  if (!result.ok) {
    throw new ApiError(options, result, "Generic Error");
  }
};
var request = (config, options) => {
  return new CancelablePromise(async (resolve3, reject, onCancel) => {
    try {
      const url = getUrl(config, options);
      const formData = getFormData(options);
      const body = getRequestBody(options);
      const headers = await getHeaders(config, options);
      if (!onCancel.isCancelled) {
        const response = await sendRequest(
          options,
          url,
          body,
          formData,
          headers,
          onCancel
        );
        const responseBody = await getResponseBody(response);
        const responseHeader = getResponseHeader(
          response,
          options.responseHeader
        );
        const result = {
          url,
          ok: response.ok,
          status: response.status,
          statusText: response.statusText,
          body: responseHeader ?? responseBody
        };
        catchErrorCodes(options, result);
        resolve3(result.body);
      }
    } catch (error) {
      reject(error);
    }
  });
};

// src/common/open-api/services/HumanTaskService.ts
var HumanTaskService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * List tasks by filters - task name, state, assignee, assignee type, claimed
   * @param state
   * @param assignee
   * @param assigneeType
   * @param claimedBy
   * @param taskName
   * @param freeText
   * @param includeInputOutput
   * @returns SearchResultHumanTaskEntry OK
   * @throws ApiError
   */
  getTasksByFilter(state, assignee, assigneeType, claimedBy, taskName, freeText, includeInputOutput = false) {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/tasks",
      query: {
        "state": state,
        "assignee": assignee,
        "assigneeType": assigneeType,
        "claimedBy": claimedBy,
        "taskName": taskName,
        "freeText": freeText,
        "includeInputOutput": includeInputOutput
      }
    });
  }
  /**
   * Get task load grouped by workflow name and task ref name per user
   * @returns HumanTaskLoad OK
   * @throws ApiError
   */
  getTaskLoad() {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/tasks/load"
    });
  }
  /**
   * Search human tasks
   * @param queryId
   * @param start
   * @param size
   * @param freeText
   * @param query
   * @param jsonQuery
   * @param includeInputOutput
   * @returns HTScrollableSearchResultHumanTaskEntry OK
   * @throws ApiError
   */
  search1(queryId, start, size = 100, freeText = "*", query, jsonQuery, includeInputOutput = false) {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/tasks/search",
      query: {
        "queryId": queryId,
        "start": start,
        "size": size,
        "freeText": freeText,
        "query": query,
        "jsonQuery": jsonQuery,
        "includeInputOutput": includeInputOutput
      }
    });
  }
  /**
   * If the workflow is disconnected from tasks, this API can be used to clean up
   * @param taskId
   * @returns any OK
   * @throws ApiError
   */
  updateTaskOutput1(taskId) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/human/tasks/{taskId}",
      path: {
        "taskId": taskId
      }
    });
  }
  /**
   * Get a task
   * @param taskId
   * @returns HumanTaskEntry OK
   * @throws ApiError
   */
  getTask1(taskId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/tasks/{taskId}",
      path: {
        "taskId": taskId
      }
    });
  }
  /**
   * Get human task action log entries by task id
   * @param taskId
   * @returns HumanTaskActionLogEntry OK
   * @throws ApiError
   */
  getActionLogs(taskId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/tasks/{taskId}/actionLogs",
      path: {
        "taskId": taskId
      }
    });
  }
  /**
   * Claim a task by authenticated Conductor user
   * @param taskId
   * @returns any OK
   * @throws ApiError
   */
  claimTask(taskId) {
    return this.httpRequest.request({
      method: "POST",
      url: "/human/tasks/{taskId}/claim",
      path: {
        "taskId": taskId
      }
    });
  }
  /**
   * Claim a task to an external user
   * @param taskId
   * @param userId
   * @returns any OK
   * @throws ApiError
   */
  assignAndClaim(taskId, userId) {
    return this.httpRequest.request({
      method: "POST",
      url: "/human/tasks/{taskId}/externalUser/{userId}",
      path: {
        "taskId": taskId,
        "userId": userId
      }
    });
  }
  /**
   * Release a task without completing it
   * @param taskId
   * @param requestBody
   * @returns any OK
   * @throws ApiError
   */
  reassignTask(taskId, requestBody) {
    return this.httpRequest.request({
      method: "POST",
      url: "/human/tasks/{taskId}/reassign",
      path: {
        "taskId": taskId
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Release a task without completing it
   * @param taskId
   * @returns any OK
   * @throws ApiError
   */
  releaseTask(taskId) {
    return this.httpRequest.request({
      method: "POST",
      url: "/human/tasks/{taskId}/release",
      path: {
        "taskId": taskId
      }
    });
  }
  /**
   * Get human task state log entries by task id
   * @param taskId
   * @returns HumanTaskStateLogEntry OK
   * @throws ApiError
   */
  getStateLogs(taskId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/tasks/{taskId}/stateLogs",
      path: {
        "taskId": taskId
      }
    });
  }
  /**
   * Update task output, optionally complete
   * @param taskId
   * @param requestBody
   * @param complete
   * @returns any OK
   * @throws ApiError
   */
  updateTaskOutput(taskId, requestBody, complete = false) {
    return this.httpRequest.request({
      method: "POST",
      url: "/human/tasks/{taskId}/update",
      path: {
        "taskId": taskId
      },
      query: {
        "complete": complete
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Delete human task templates by name
   * @param name
   * @returns any OK
   * @throws ApiError
   */
  deleteTemplatesByName(name) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/human/template",
      query: {
        "name": name
      }
    });
  }
  /**
   * List all human task templates or get templates by name, or a template by name and version
   * @param name
   * @param version
   * @returns HumanTaskTemplateEntry OK
   * @throws ApiError
   */
  getAllTemplates(name, version) {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/template",
      query: {
        "name": name,
        "version": version
      }
    });
  }
  /**
   * Save human task template
   * @param requestBody
   * @param newVersion
   * @returns string OK
   * @throws ApiError
   */
  saveTemplate(requestBody, newVersion = false) {
    return this.httpRequest.request({
      method: "POST",
      url: "/human/template",
      query: {
        "newVersion": newVersion
      },
      body: requestBody,
      mediaType: "application/json"
    });
  }
  /**
   * Delete human task template
   * @param id
   * @returns any OK
   * @throws ApiError
   */
  deleteTemplateById(id) {
    return this.httpRequest.request({
      method: "DELETE",
      url: "/human/template/{id}",
      path: {
        "id": id
      }
    });
  }
  /**
   * Get human task template by id
   * @param id
   * @returns HumanTaskTemplateEntry OK
   * @throws ApiError
   */
  getTemplateById(id) {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/template/{id}",
      path: {
        "id": id
      }
    });
  }
};

// src/common/open-api/services/HumanTaskResourceService.ts
var HumanTaskResourceService = class {
  constructor(httpRequest) {
    this.httpRequest = httpRequest;
  }
  /**
   * Get Conductor task by id (for human tasks only)
   * @param taskId
   * @returns Task OK
   * @throws ApiError
   */
  getConductorTaskById(taskId) {
    return this.httpRequest.request({
      method: "GET",
      url: "/human/tasks/{taskId}/conductorTask",
      path: {
        "taskId": taskId
      }
    });
  }
};

// src/common/open-api/ConductorClient.ts
var defaultRequestHandler = (request3, config, options) => request3(config, options);
var ConductorClient = class {
  constructor(config, requestHandler = defaultRequestHandler) {
    const resolvedConfig = {
      BASE: config?.serverUrl ?? "http://localhost:8080",
      VERSION: config?.VERSION ?? "0",
      WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,
      CREDENTIALS: config?.CREDENTIALS ?? "include",
      TOKEN: config?.TOKEN,
      USERNAME: config?.USERNAME,
      PASSWORD: config?.PASSWORD,
      HEADERS: config?.HEADERS,
      ENCODE_PATH: config?.ENCODE_PATH
    };
    this.request = {
      config: resolvedConfig,
      request: (apiConfig) => {
        return requestHandler(
          request,
          { ...resolvedConfig, TOKEN: this.token },
          apiConfig
        );
      }
    };
    this.token = config?.TOKEN;
    this.eventResource = new EventResourceService(this.request);
    this.healthCheckResource = new HealthCheckResourceService(this.request);
    this.metadataResource = new MetadataResourceService(this.request);
    this.schedulerResource = new SchedulerResourceService(this.request);
    this.taskResource = new TaskResourceService(this.request);
    this.tokenResource = new TokenResourceService(this.request);
    this.workflowBulkResource = new WorkflowBulkResourceService(this.request);
    this.workflowResource = new WorkflowResourceService(this.request);
    this.humanTask = new HumanTaskService(this.request);
    this.humanTaskResource = new HumanTaskResourceService(this.request);
  }
  stop() {
  }
};

// src/common/open-api/core/BaseHttpRequest.ts
var BaseHttpRequest = class {
  constructor(config) {
    this.config = config;
  }
};

// src/task/constants.ts
var DEFAULT_POLL_INTERVAL = 100;
var DEFAULT_CONCURRENCY = 1;
var DEFAULT_WARN_AT_O = 100;
var DEFAULT_BATCH_POLLING_TIMEOUT = 100;

// src/task/Poller.ts
var Poller = class {
  constructor(pollerId, pollFunction, performWorkFunction, pollerOptions, logger) {
    this.performWorkFunction = async () => {
    };
    this.polling = false;
    this._tasksInProcess = 0;
    this._counterAtO = 0;
    this._pollerId = "";
    this.options = {
      pollInterval: DEFAULT_POLL_INTERVAL,
      concurrency: DEFAULT_CONCURRENCY,
      warnAtO: DEFAULT_WARN_AT_O
    };
    this.logger = noopLogger;
    /**
     * Starts polling for work
     */
    this.startPolling = () => {
      if (this.polling) {
        throw new Error("Runner is already started");
      }
      this._tasksInProcess = 0;
      this.polling = true;
      this.poll();
    };
    /**
     * Stops Polling for work
     */
    this.stopPolling = async () => {
      this.polling = false;
      clearTimeout(this.timeoutHandler);
    };
    this.performWork = async (work) => {
      await this.performWorkFunction(work);
      this._tasksInProcess--;
    };
    this.poll = async () => {
      while (this.isPolling) {
        try {
          const count = Math.max(
            0,
            this.options.concurrency - this._tasksInProcess
          );
          if (count === 0) {
            this.logger.debug(
              "Max in process reached, Will skip polling for " + this._pollerId
            );
            this._counterAtO++;
            if (this._counterAtO > (this.options.warnAtO ?? 100)) {
              this.logger.info(
                `Not polling anything because in process tasks is maxed as concurrency level. ${this._pollerId}`
              );
            }
          } else {
            this._counterAtO = 0;
            const tasksResult = await this.pollFunction(count);
            this._tasksInProcess = this._tasksInProcess + (tasksResult ?? []).length;
            tasksResult.forEach(this.performWork);
          }
        } catch (e) {
          this.logger.error(`Error polling for tasks: ${e.message}`, e);
        }
        await new Promise(
          (r) => this.isPolling ? this.timeoutHandler = setTimeout(
            () => r(true),
            this.options.pollInterval
          ) : r(true)
        );
      }
    };
    this._pollerId = pollerId;
    this.pollFunction = pollFunction;
    this.performWorkFunction = performWorkFunction;
    this.options = { ...this.options, ...pollerOptions };
    this.logger = logger || noopLogger;
  }
  get isPolling() {
    return this.polling;
  }
  get tasksInProcess() {
    return this._tasksInProcess;
  }
  updateOptions(options) {
    const newOptions = { ...this.options, ...options };
    this.options = newOptions;
  }
};

// src/task/helpers.ts
var optionEquals = (oldOptions, newOptions) => {
  const newOptionEntries = Object.entries(newOptions);
  const oldOptionsEntries = Object.entries(oldOptions);
  return newOptionEntries.length === oldOptionsEntries.length && newOptionEntries.every(
    ([key, value]) => oldOptions[key] === value
  );
};

// src/task/TaskRunner.ts
var DEFAULT_ERROR_MESSAGE = "An unknown error occurred";
var MAX_RETRIES = 3;
var noopErrorHandler = (__error) => {
};
var defaultRunnerOptions = {
  workerID: "",
  pollInterval: DEFAULT_POLL_INTERVAL,
  domain: void 0,
  concurrency: DEFAULT_CONCURRENCY,
  batchPollingTimeout: DEFAULT_BATCH_POLLING_TIMEOUT
};
var TaskRunner = class {
  constructor({
    worker,
    taskResource,
    options,
    logger = noopLogger,
    onError: errorHandler = noopErrorHandler
  }) {
    /**
     * Starts polling for work
     */
    this.startPolling = () => {
      this.poller.startPolling();
      this.logger.info(
        `TaskWorker ${this.worker.taskDefName} initialized with concurrency of ${this.poller.options.concurrency} and poll interval of ${this.poller.options.pollInterval}`
      );
    };
    /**
     * Stops Polling for work
     */
    this.stopPolling = async () => {
      await this.poller.stopPolling();
    };
    this.batchPoll = async (count) => {
      const { workerID } = this.options;
      const tasks = await this.taskResource.batchPoll(
        this.worker.taskDefName,
        workerID,
        this.worker.domain ?? this.options.domain,
        count,
        this.options.batchPollingTimeout ?? 100
        // default batch poll defined in the method
      );
      return tasks;
    };
    this.updateTaskWithRetry = async (task, taskResult) => {
      const { workerID } = this.options;
      let retryCount = 0;
      while (retryCount < MAX_RETRIES) {
        try {
          await this.taskResource.updateTask1({
            ...taskResult,
            workerId: workerID
          });
          return;
        } catch (error) {
          this.errorHandler(error, task);
          this.logger.error(
            `Error updating task ${taskResult.taskId} on retry ${retryCount}`,
            error
          );
          retryCount++;
          await new Promise((r) => setTimeout(() => r(true), retryCount * 10));
        }
      }
      this.logger.error(
        `Unable to update task ${taskResult.taskId} after ${retryCount} retries`
      );
    };
    this.executeTask = async (task) => {
      try {
        const result = await this.worker.execute(task);
        await this.updateTaskWithRetry(task, {
          ...result,
          workflowInstanceId: task.workflowInstanceId,
          taskId: task.taskId
        });
        this.logger.debug(`Task has executed successfully ${task.taskId}`);
      } catch (error) {
        await this.updateTaskWithRetry(task, {
          workflowInstanceId: task.workflowInstanceId,
          taskId: task.taskId,
          reasonForIncompletion: error?.message ?? DEFAULT_ERROR_MESSAGE,
          status: "FAILED",
          outputData: {}
        });
        this.errorHandler(error, task);
        this.logger.error(`Error executing ${task.taskId}`, error);
      }
    };
    this.handleUnknownError = (unknownError) => {
      let message = "";
      let stack = "";
      if (unknownError.stack) {
        stack = unknownError.stack;
      }
      if (unknownError.message) {
        message = unknownError.message;
      }
      this.logger.error(
        `Error for ${this.worker.taskDefName}: error: ${message}, stack: ${stack}`
      );
    };
    this.taskResource = taskResource;
    this.logger = logger;
    this.worker = worker;
    this.options = { ...defaultRunnerOptions, ...options };
    this.errorHandler = errorHandler;
    this.poller = new Poller(
      worker.taskDefName,
      this.batchPoll,
      this.executeTask,
      {
        concurrency: worker.concurrency ?? options.concurrency,
        pollInterval: worker.pollInterval ?? options.pollInterval
      },
      this.logger
    );
  }
  get isPolling() {
    return this.poller.isPolling;
  }
  updateOptions(options) {
    const newOptions = { ...this.options, ...options };
    const isOptionsUpdated = !optionEquals(this.options, newOptions);
    if (isOptionsUpdated) {
      this.poller.updateOptions({
        concurrency: newOptions.concurrency,
        pollInterval: newOptions.pollInterval
      });
      this.logger.info(
        `TaskWorker ${this.worker.taskDefName} configuration updated with concurrency of ${this.poller.options.concurrency} and poll interval of ${this.poller.options.pollInterval}`
      );
    }
    this.options = newOptions;
  }
  get getOptions() {
    return this.options;
  }
};

// src/task/TaskManager.ts
var import_os = __toESM(require("os"));
var defaultManagerOptions = {
  workerID: "",
  pollInterval: DEFAULT_POLL_INTERVAL,
  domain: void 0,
  concurrency: DEFAULT_CONCURRENCY,
  batchPollingTimeout: DEFAULT_BATCH_POLLING_TIMEOUT
};
function workerId(options) {
  return options.workerID ?? import_os.default.hostname();
}
var TaskManager = class {
  constructor(client, workers, config = {}) {
    this.workerRunners = /* @__PURE__ */ new Map();
    this.polling = false;
    this.workerManagerWorkerOptions = (worker) => {
      return {
        ...this.options,
        concurrency: worker.concurrency ?? this.options.concurrency,
        pollInterval: worker.pollInterval ?? this.options.pollInterval,
        domain: worker.domain ?? this.options.domain
      };
    };
    this.updatePollingOptionForWorker = (workerTaskDefName, options) => {
      const maybeRunner = this.workerRunners.get(workerTaskDefName);
      if (maybeRunner != null) {
        maybeRunner.updateOptions(options);
      } else {
        this.logger.info(
          `No runner found for worker with taskDefName: ${workerTaskDefName}`
        );
      }
    };
    /**
     * new options will get merged to existing options
     * @param options new options to update polling options
     */
    this.updatePollingOptions = (options) => {
      this.workers.forEach((worker) => {
        const newOptions = {
          ...this.workerManagerWorkerOptions(worker),
          ...options
        };
        this.updatePollingOptionForWorker(worker.taskDefName, newOptions);
      });
      this.options.concurrency = options.concurrency ?? this.options.concurrency;
      this.options.pollInterval = options.pollInterval ?? this.options.pollInterval;
    };
    this.sanityCheck = () => {
      if (this.workers.length === 0) {
        throw new Error("No workers supplied to TaskManager");
      }
      const workerIDs = /* @__PURE__ */ new Set();
      for (const item of this.workers) {
        if (workerIDs.has(item.taskDefName)) {
          throw new Error(`Duplicate worker taskDefName: ${item.taskDefName}`);
        }
        workerIDs.add(item.taskDefName);
      }
    };
    /**
     * Start polling for tasks
     */
    this.startPolling = () => {
      this.sanityCheck();
      this.workers.forEach((worker) => {
        const options = this.workerManagerWorkerOptions(worker);
        const runner = new TaskRunner({
          worker,
          options,
          taskResource: this.client.taskResource,
          logger: this.logger,
          onError: this.errorHandler
        });
        runner.startPolling();
        this.workerRunners.set(worker.taskDefName, runner);
      });
      this.polling = true;
    };
    /**
     * Stops polling for tasks
     */
    this.stopPolling = async () => {
      for (const [workerTaskDefName, runner] of this.workerRunners) {
        this.logger.debug(`Stopping taskDefName=${workerTaskDefName}`);
        await runner.stopPolling();
        this.workerRunners.delete(workerTaskDefName);
      }
      this.polling = false;
    };
    if (!workers) {
      throw new Error(
        "No workers supplied to TaskManager. Please pass an array of workers."
      );
    }
    this.client = client;
    this.logger = config.logger ?? new DefaultLogger();
    this.errorHandler = config.onError ?? noopErrorHandler;
    this.workers = workers;
    const providedOptions = config.options ?? {};
    this.options = {
      ...defaultManagerOptions,
      ...providedOptions,
      workerID: workerId(providedOptions)
    };
  }
  get isPolling() {
    return this.polling;
  }
};

// src/core/types.ts
var ConductorError = class extends Error {
  constructor(message, innerError) {
    super(message);
    this._trace = innerError;
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
  }
};

// src/core/helpers.ts
var errorMapper = (error) => new ConductorError(error?.body?.message, error);
var tryCatchReThrow = (fn) => {
  try {
    return fn();
  } catch (error) {
    throw errorMapper(error);
  }
};

// src/core/executor.ts
var RETRY_TIME_IN_MILLISECONDS = 1e4;
var WorkflowExecutor = class {
  constructor(client) {
    this._client = client;
  }
  /**
   * Will persist a workflow in conductor
   * @param override If true will override the existing workflow with the definition
   * @param workflow Complete workflow definition
   * @returns null
   */
  registerWorkflow(override, workflow2) {
    return tryCatchReThrow(
      () => this._client.metadataResource.create(workflow2, override)
    );
  }
  /**
   * Takes a StartWorkflowRequest. returns a Promise<string> with the workflowInstanceId of the running workflow
   * @param workflowRequest
   * @returns
   */
  startWorkflow(workflowRequest) {
    return tryCatchReThrow(
      () => this._client.workflowResource.startWorkflow(workflowRequest)
    );
  }
  /**
   * Execute a workflow synchronously. returns a Promise<WorkflowRun> with details of the running workflow
   * @param workflowRequest
   * @returns
   */
  executeWorkflow(workflowRequest, name, version, requestId, waitUntilTaskRef = "") {
    return tryCatchReThrow(
      () => this._client.workflowResource.executeWorkflow(
        workflowRequest,
        name,
        version,
        requestId,
        waitUntilTaskRef
      )
    );
  }
  startWorkflows(workflowsRequest) {
    return tryCatchReThrow(() => workflowsRequest.map(this.startWorkflow));
  }
  /**
   * Takes an workflowInstanceId and an includeTasks and an optional retry parameter returns the whole execution status.
   * If includeTasks flag is provided. Details of tasks execution will be returned as well,
   * retry specifies the amount of retrys before throwing an error.
   *
   * @param workflowInstanceId
   * @param includeTasks
   * @param retry
   * @returns
   */
  async getWorkflow(workflowInstanceId, includeTasks, retry = 0) {
    try {
      const workflowStatus = await this._client.workflowResource.getExecutionStatus(
        workflowInstanceId,
        includeTasks
      );
      return workflowStatus;
    } catch (error) {
      if (![500, 404, 403].includes(error.status) || retry === 0) {
        throw errorMapper(error);
      }
    }
    await new Promise(
      (res) => setTimeout(() => res(true), RETRY_TIME_IN_MILLISECONDS)
    );
    return this.getWorkflow(workflowInstanceId, includeTasks, retry - 1);
  }
  /**
   *  Returns a summary of the current workflow status.
   *
   * @param workflowInstanceId current running workflow
   * @param includeOutput flag to include output
   * @param includeVariables flag to include variable
   * @returns Promise<WorkflowStatus>
   */
  getWorkflowStatus(workflowInstanceId, includeOutput, includeVariables) {
    return tryCatchReThrow(
      () => this._client.workflowResource.getWorkflowStatusSummary(
        workflowInstanceId,
        includeOutput,
        includeVariables
      )
    );
  }
  /**
   * Pauses a running workflow
   * @param workflowInstanceId current workflow execution
   * @returns
   */
  pause(workflowInstanceId) {
    return tryCatchReThrow(
      () => this._client.workflowResource.pauseWorkflow(workflowInstanceId)
    );
  }
  /**
   * Reruns workflowInstanceId workflow. with new parameters
   *
   * @param workflowInstanceId current workflow execution
   * @param rerunWorkflowRequest Rerun Workflow Execution Request
   * @returns
   */
  reRun(workflowInstanceId, rerunWorkflowRequest = {}) {
    return tryCatchReThrow(
      () => this._client.workflowResource.rerun(
        workflowInstanceId,
        rerunWorkflowRequest
      )
    );
  }
  /**
   * Restarts workflow with workflowInstanceId, if useLatestDefinition uses last defintion
   * @param workflowInstanceId
   * @param useLatestDefinitions
   * @returns
   */
  restart(workflowInstanceId, useLatestDefinitions) {
    return tryCatchReThrow(
      () => this._client.workflowResource.restart1(
        workflowInstanceId,
        useLatestDefinitions
      )
    );
  }
  /**
   * Resumes a previously paused execution
   *
   * @param workflowInstanceId Running workflow workflowInstanceId
   * @returns
   */
  resume(workflowInstanceId) {
    return tryCatchReThrow(
      () => this._client.workflowResource.resumeWorkflow(workflowInstanceId)
    );
  }
  /**
   * Retrys workflow from last failing task
   * if resumeSubworkflowTasks is true will resume tasks in spawned subworkflows
   *
   * @param workflowInstanceId
   * @param resumeSubworkflowTasks
   * @returns
   */
  retry(workflowInstanceId, resumeSubworkflowTasks) {
    return tryCatchReThrow(
      () => this._client.workflowResource.retry1(
        workflowInstanceId,
        resumeSubworkflowTasks
      )
    );
  }
  /**
   * Searches for existing workflows given the following querys
   *
   * @param start
   * @param size
   * @param query
   * @param freeText
   * @param sort
   * @param skipCache
   * @returns
   */
  search(start, size, query, freeText, sort = "", skipCache = false) {
    const queryId = void 0;
    return tryCatchReThrow(
      () => this._client.workflowResource.search1(
        queryId,
        start,
        size,
        sort,
        freeText,
        query,
        skipCache
      )
    );
  }
  /**
   * Skips a task of a running workflow.
   * by providing a skipTaskRequest you can set the input and the output of the skipped tasks
   * @param workflowInstanceId
   * @param taskReferenceName
   * @param skipTaskRequest
   * @returns
   */
  skipTasksFromWorkflow(workflowInstanceId, taskReferenceName, skipTaskRequest) {
    return tryCatchReThrow(
      () => this._client.workflowResource.skipTaskFromWorkflow(
        workflowInstanceId,
        taskReferenceName,
        skipTaskRequest
      )
    );
  }
  /**
   * Takes an workflowInstanceId, and terminates a running workflow
   * @param workflowInstanceId
   * @param reason
   * @returns
   */
  terminate(workflowInstanceId, reason) {
    return tryCatchReThrow(
      () => this._client.workflowResource.terminate1(workflowInstanceId, reason)
    );
  }
  /**
   * Takes a taskId and a workflowInstanceId. Will update the task for the corresponding taskId
   * @param taskId
   * @param workflowInstanceId
   * @param taskStatus
   * @param taskOutput
   * @returns
   */
  updateTask(taskId, workflowInstanceId, taskStatus, outputData) {
    const taskUpdates = {
      status: taskStatus,
      taskId,
      workflowInstanceId
    };
    return tryCatchReThrow(
      () => this._client.taskResource.updateTask1({
        outputData,
        ...taskUpdates
      })
    );
  }
  /**
   * Updates a task by reference Name
   * @param taskReferenceName
   * @param workflowInstanceId
   * @param status
   * @param taskOutput
   * @returns
   */
  updateTaskByRefName(taskReferenceName, workflowInstanceId, status, taskOutput) {
    return tryCatchReThrow(
      () => this._client.taskResource.updateTask(
        workflowInstanceId,
        taskReferenceName,
        status,
        taskOutput
      )
    );
  }
  /**
   *
   * @param taskId
   * @returns
   */
  getTask(taskId) {
    return tryCatchReThrow(() => this._client.taskResource.getTask(taskId));
  }
};

// src/core/human.ts
var HumanExecutor = class {
  constructor(client) {
    this._client = client;
  }
  /**
   * Takes a set of filter parameters. return matches of human tasks for that set of parameters
   * @param state
   * @param assignee
   * @param assigneeType
   * @param claimedBy
   * @param taskName
   * @param freeText
   * @param includeInputOutput
   * @returns
   */
  async getTasksByFilter(state, assignee, assigneeType, claimedBy, taskName, freeText, includeInputOutput = false) {
    const response = await this._client.humanTask.getTasksByFilter(
      state,
      assignee,
      assigneeType,
      claimedBy,
      taskName,
      freeText,
      includeInputOutput
    );
    if (response.results != void 0) {
      return response.results;
    }
    return [];
  }
  /**
   * Returns task for a given task id
   * @param taskId
   * @returns
   */
  getTaskById(taskId) {
    return tryCatchReThrow(() => this._client.humanTask.getTask1(taskId));
  }
  /**
   * Assigns taskId to assignee. If the task is already assigned to another user, this will fail.
   * @param taskId
   * @param assignee
   * @returns
   */
  async claimTaskAsExternalUser(taskId, assignee) {
    try {
      await this._client.humanTask.assignAndClaim(taskId, assignee);
    } catch (error) {
      throw errorMapper(error);
    }
  }
  /**
   * Claim task as conductor user
   * @param taskId
   * @returns
   */
  async claimTaskAsConductorUser(taskId) {
    try {
      await this._client.humanTask.claimTask(taskId);
    } catch (error) {
      throw errorMapper(error);
    }
  }
  /**
   * Claim task as conductor user
   * @param taskId
   * @param assignee
   * @returns
   */
  async releaseTask(taskId) {
    try {
      await this._client.humanTask.releaseTask(taskId);
    } catch (error) {
      throw errorMapper(error);
    }
  }
  /**
   * Returns a HumanTaskTemplateEntry for a given templateId
   * @param templateId
   * @returns
   */
  async getTemplateById(templateId) {
    return tryCatchReThrow(
      () => this._client.humanTask.getTemplateById(templateId)
    );
  }
  /**
   * Takes a taskId and a partial body. will update with given body
   * @param taskId
   * @param requestBody
   */
  async updateTaskOutput(taskId, requestBody) {
    try {
      await this._client.humanTask.updateTaskOutput(taskId, requestBody, false);
    } catch (error) {
      throw errorMapper(error);
    }
  }
  /**
   * Takes a taskId and an optional partial body. will complete the task with the given body
   * @param taskId
   * @param requestBody
   */
  async completeTask(taskId, requestBody = {}) {
    try {
      await this._client.humanTask.updateTaskOutput(taskId, requestBody, true);
    } catch (error) {
      throw errorMapper(error);
    }
  }
};

// src/core/sdk/doWhile.ts
var doWhileTask = (taskRefName, terminationCondition, tasks) => ({
  name: taskRefName,
  taskReferenceName: taskRefName,
  loopCondition: terminationCondition,
  inputParameters: {},
  type: "DO_WHILE" /* DO_WHILE */,
  loopOver: tasks
});
var loopForCondition = (taskRefName, valueKey) => `if ( $.${taskRefName}['iteration'] < $.${valueKey} ) { true; } else { false; }`;
var newLoopTask = (taskRefName, iterations, tasks) => ({
  name: taskRefName,
  taskReferenceName: taskRefName,
  loopCondition: loopForCondition(taskRefName, "value"),
  inputParameters: {
    value: iterations
  },
  type: "DO_WHILE" /* DO_WHILE */,
  loopOver: tasks
});

// src/core/sdk/dynamicFork.ts
var dynamicForkTask = (taskReferenceName, preForkTasks = [], dynamicTasksInput = "") => ({
  name: taskReferenceName,
  taskReferenceName,
  inputParameters: {
    dynamicTasks: preForkTasks,
    dynamicTasksInput
  },
  type: "FORK_JOIN_DYNAMIC" /* FORK_JOIN_DYNAMIC */,
  dynamicForkTasksParam: "dynamicTasks",
  dynamicForkTasksInputParamName: "dynamicTasksInput"
});

// src/core/sdk/event.ts
var eventTask = (taskReferenceName, eventPrefix, eventSuffix) => ({
  name: taskReferenceName,
  taskReferenceName,
  sink: `${eventPrefix}:${eventSuffix}`,
  type: "EVENT" /* EVENT */
});
var sqsEventTask = (taskReferenceName, queueName) => eventTask(taskReferenceName, "sqs", queueName);
var conductorEventTask = (taskReferenceName, eventName) => eventTask(taskReferenceName, "conductor", eventName);

// src/core/generators/common.ts
var randomChars = (n = 7) => (Math.random() + 1).toString(36).substring(n);
var taskNameGenerator = (taskType) => `${taskType}__task_${randomChars(7)}`;
var taskReferenceNameGenerator = (taskName) => `${taskName}_ref`;
var nameTaskNameGenerator = (taskType, maybeOverrides = {}) => {
  const name = maybeOverrides?.name ?? taskNameGenerator(taskType);
  return {
    name,
    taskReferenceName: taskReferenceNameGenerator(name)
  };
};
function mapArrValues(arrayTransformer, mapWithValues) {
  return Object.fromEntries(
    Object.entries(mapWithValues).map(([key, value]) => [
      key,
      arrayTransformer(value)
    ])
  );
}

// src/core/generators/SimpleTask.ts
var generateSimpleTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("simple", overrides),
  inputParameters: {},
  ...overrides,
  type: "SIMPLE" /* SIMPLE */
});

// src/core/generators/DoWhileTask.ts
var generateDoWhileTask = (overrides = {}, nestedTasksMapper) => ({
  ...nameTaskNameGenerator("doWhile", overrides),
  inputParameters: {},
  startDelay: 0,
  optional: false,
  asyncComplete: false,
  loopCondition: "",
  ...overrides,
  loopOver: nestedTasksMapper(overrides?.loopOver || []),
  type: "DO_WHILE" /* DO_WHILE */
});

// src/core/generators/EventTask.ts
var generateEventTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("event", overrides),
  sink: "sqs:sqs_queue_name",
  asyncComplete: false,
  ...overrides,
  type: "EVENT" /* EVENT */
});

// src/core/generators/ForkJoin.ts
var generateForkJoinTask = (overrides = {}, nestedMapper) => ({
  ...nameTaskNameGenerator("forkJoin", overrides),
  inputParameters: {},
  ...overrides,
  type: "FORK_JOIN" /* FORK_JOIN */,
  forkTasks: (overrides?.forkTasks || []).map(nestedMapper)
});
var generateJoinTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("join", overrides),
  inputParameters: {},
  joinOn: [],
  optional: false,
  asyncComplete: false,
  ...overrides,
  type: "JOIN" /* JOIN */
});

// src/core/generators/HttpTask.ts
var generateHTTPTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("httpTask", overrides),
  inputParameters: {
    http_request: {
      uri: "https://jsonplaceholder.typicode.com/posts/${workflow.input.queryid}",
      method: "GET"
    }
  },
  ...overrides,
  type: "HTTP" /* HTTP */
});

// src/core/generators/InlineTask.ts
var defaultInputParams = {
  value: "${workflow.input.value}",
  evaluatorType: "graaljs",
  expression: "true"
};
var generateEvaluationCode = (inputParametersPartial = {}) => {
  const inlinePartialDefJavascript = inputParametersPartial;
  const inlineExpression = inlinePartialDefJavascript?.expression;
  if (inlineExpression !== void 0 && typeof inlineExpression === "function") {
    const resultingFunction = inlineExpression();
    const resultingFunctionAsString = resultingFunction.toString();
    const toReturn = {
      evaluatorType: "graaljs",
      ...inputParametersPartial || { value: "true" },
      expression: `(${resultingFunctionAsString})();`
    };
    return toReturn;
  }
  return {
    ...defaultInputParams,
    evaluatorType: "graaljs",
    ...inputParametersPartial
  };
};
var generateInlineTask = (override = {}) => ({
  ...nameTaskNameGenerator("inline", override),
  ...override,
  inputParameters: generateEvaluationCode(override?.inputParameters || {}),
  type: "INLINE" /* INLINE */
});

// src/core/generators/JsonJQTransform.ts
var generateJQTransformTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("jqTransform", overrides),
  inputParameters: {
    key1: {
      value1: ["a", "b"]
    },
    key2: {
      value2: ["c", "d"]
    },
    queryExpression: "{ key3: (.key1.value1 + .key2.value2) }"
  },
  ...overrides,
  type: "JSON_JQ_TRANSFORM" /* JSON_JQ_TRANSFORM */
});

// src/core/generators/KafkaTask.ts
var generateKafkaPublishTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("kafka", overrides),
  inputParameters: {
    kafka_request: {
      topic: "topic",
      value: "",
      bootStrapServers: "localhost:9092",
      headers: {},
      key: "123",
      keySerializer: "org.apache.kafka.common.serialization.IntegerSerializer"
    }
  },
  ...overrides,
  type: "KAFKA_PUBLISH" /* KAFKA_PUBLISH */
});

// src/core/generators/SubWorkflowTask.ts
var generateSubWorkflowTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("subWorkflow", overrides),
  inputParameters: {},
  subWorkflowParam: {
    name: "name",
    version: 1,
    taskToDomain: {}
  },
  ...overrides,
  type: "SUB_WORKFLOW" /* SUB_WORKFLOW */
});

// src/core/generators/SetVariableTask.ts
var generateSetVariableTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("setVariable", overrides),
  inputParameters: {},
  ...overrides,
  type: "SET_VARIABLE" /* SET_VARIABLE */
});

// src/core/generators/TerminateTask.ts
var generateTerminateTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("terminate", overrides),
  inputParameters: {
    terminationStatus: "COMPLETED",
    workflowOutput: {}
  },
  startDelay: 0,
  optional: false,
  ...overrides,
  type: "TERMINATE" /* TERMINATE */
});

// src/core/generators/WaitTask.ts
var generateWaitTask = (overrides = {}) => ({
  ...nameTaskNameGenerator("wait", overrides),
  ...overrides,
  inputParameters: {},
  type: "WAIT" /* WAIT */
});

// src/core/generators/SwitchTask.ts
var fillSwitchTaskBranches = (task, mapper) => ({
  decisionCases: mapArrValues(mapper, task?.decisionCases || {}),
  defaultCase: mapper(task?.defaultCase || [])
});
var generateSwitchTask = (overrides = {}, nestedTasksMapper) => ({
  ...nameTaskNameGenerator("switch", overrides),
  inputParameters: {
    switchCaseValue: ""
  },
  evaluatorType: "value-param",
  expression: "switchCaseValue",
  ...overrides,
  ...fillSwitchTaskBranches(overrides, nestedTasksMapper),
  type: "SWITCH" /* SWITCH */
});

// src/core/generators/WorkflowGenerator.ts
var workflowGenerator = (overrides) => ({
  name: "NewWorkflow_3nxbi",
  description: "Edit or extend this sample workflow. Set the workflow name to get started",
  version: 1,
  tasks: [],
  inputParameters: [],
  outputParameters: {},
  schemaVersion: 2,
  restartable: true,
  workflowStatusListenerEnabled: false,
  ownerEmail: "james.stuart@orkes.io",
  timeoutPolicy: "ALERT_ONLY",
  timeoutSeconds: 0,
  ...overrides
});

// src/core/generators/ForkJoinDynamicTask.ts
var generateForkJoinDynamic = (overrides = {}) => ({
  ...nameTaskNameGenerator("forkJoinDynamic", overrides),
  inputParameters: {
    dynamicTasks: "",
    dynamicTasksInput: ""
  },
  dynamicForkTasksParam: "dynamicTasks",
  dynamicForkTasksInputParamName: "dynamicTasksInput",
  startDelay: 0,
  optional: false,
  asyncComplete: false,
  ...overrides,
  type: "FORK_JOIN_DYNAMIC" /* FORK_JOIN_DYNAMIC */
});

// src/core/generators/generator.ts
var filledTaskDef = (task) => {
  const taskType = task.type;
  switch (taskType) {
    case "SWITCH" /* SWITCH */:
      return generateSwitchTask(task, taskGenMapper);
    case "SIMPLE" /* SIMPLE */:
      return generateSimpleTask(task);
    case "DO_WHILE" /* DO_WHILE */:
      return generateDoWhileTask(task, taskGenMapper);
    case "EVENT" /* EVENT */:
      return generateEventTask(task);
    case "FORK_JOIN" /* FORK_JOIN */:
      return generateForkJoinTask(task, taskGenMapper);
    case "FORK_JOIN_DYNAMIC" /* FORK_JOIN_DYNAMIC */:
      return generateForkJoinDynamic(task);
    case "HTTP" /* HTTP */:
      return generateHTTPTask(task);
    case "INLINE" /* INLINE */:
      return generateInlineTask(task);
    case "JOIN" /* JOIN */:
      return generateJoinTask(task);
    case "JSON_JQ_TRANSFORM" /* JSON_JQ_TRANSFORM */:
      return generateJQTransformTask(task);
    case "KAFKA_PUBLISH" /* KAFKA_PUBLISH */:
      return generateKafkaPublishTask(task);
    case "SUB_WORKFLOW" /* SUB_WORKFLOW */:
      return generateSubWorkflowTask(task);
    case "SET_VARIABLE" /* SET_VARIABLE */:
      return generateSetVariableTask(task);
    case "TERMINATE" /* TERMINATE */:
      return generateTerminateTask(task);
    case "WAIT" /* WAIT */:
      return generateWaitTask(task);
    default:
      return generateSimpleTask(task);
  }
};
var taskGenMapper = (tasks) => tasks.reduce((acc, task, idx) => {
  const filledTask = filledTaskDef(task);
  const maybeNextTask = tasks.length >= idx + 1 ? tasks[idx + 1] : void 0;
  return acc.concat(maybeAddJoinTask(filledTask, maybeNextTask));
}, []);
var maybeAddJoinTask = (currentTask, maybeNextTask) => {
  if ((currentTask.type === "FORK_JOIN" /* FORK_JOIN */ || currentTask.type === "FORK_JOIN_DYNAMIC" /* FORK_JOIN_DYNAMIC */) && maybeNextTask != null && maybeNextTask.type !== "JOIN" /* JOIN */) {
    return [currentTask, generateJoinTask({})];
  }
  return currentTask;
};
var generate = (overrides) => {
  const maybeTasks = overrides.tasks || [];
  const generatedTasks = taskGenMapper(maybeTasks);
  return workflowGenerator({ ...overrides, tasks: generatedTasks });
};

// src/core/generators/index.ts
var generateSwitchTask2 = (overrides = {}, nestedTasksMapper = taskGenMapper) => generateSwitchTask(overrides, nestedTasksMapper);
var generateDoWhileTask2 = (overrides = {}, nestedTasksMapper = taskGenMapper) => generateDoWhileTask(overrides, nestedTasksMapper);
var generateForkJoinTask2 = (overrides = {}, nestedMapper = taskGenMapper) => generateForkJoinTask(overrides, nestedMapper);

// src/core/sdk/forkJoin.ts
var forkTask = (taskReferenceName, forkTasks) => ({
  taskReferenceName,
  name: taskReferenceName,
  type: "FORK_JOIN" /* FORK_JOIN */,
  forkTasks: [forkTasks]
});
var forkTaskJoin = (taskReferenceName, forkTasks) => [
  forkTask(taskReferenceName, forkTasks),
  generateJoinTask({ name: `${taskReferenceName}_join` })
];

// src/core/sdk/http.ts
var httpTask = (taskReferenceName, inputParameters) => ({
  name: taskReferenceName,
  taskReferenceName,
  inputParameters: {
    http_request: inputParameters
  },
  type: "HTTP" /* HTTP */
});

// src/core/sdk/inline.ts
var inlineTask = (taskReferenceName, script, evaluatorType = "javascript") => ({
  name: taskReferenceName,
  taskReferenceName,
  inputParameters: {
    evaluatorType,
    expression: script
  },
  type: "INLINE" /* INLINE */
});

// src/core/sdk/join.ts
var joinTask = (taskReferenceName, joinOn) => ({
  name: taskReferenceName,
  taskReferenceName,
  joinOn,
  type: "JOIN" /* JOIN */
});

// src/core/sdk/jsonJq.ts
var jsonJqTask = (taskReferenceName, script) => ({
  name: taskReferenceName,
  taskReferenceName,
  type: "JSON_JQ_TRANSFORM" /* JSON_JQ_TRANSFORM */,
  inputParameters: {
    queryExpression: script
  }
});

// src/core/sdk/kafkaPublish.ts
var kafkaPublishTask = (taskReferenceName, kafka_request) => ({
  taskReferenceName,
  name: taskReferenceName,
  type: "KAFKA_PUBLISH" /* KAFKA_PUBLISH */,
  inputParameters: {
    kafka_request
  }
});

// src/core/sdk/setVariable.ts
var setVariableTask = (taskReferenceName, inputParameters) => ({
  name: taskReferenceName,
  taskReferenceName,
  type: "SET_VARIABLE" /* SET_VARIABLE */,
  inputParameters
});

// src/core/sdk/simple.ts
var simpleTask = (taskReferenceName, name, inputParameters) => ({
  name,
  taskReferenceName,
  inputParameters,
  type: "SIMPLE" /* SIMPLE */
});

// src/core/sdk/subWorkflow.ts
var subWorkflowTask = (taskReferenceName, workflowName, version) => ({
  name: taskReferenceName,
  taskReferenceName,
  subWorkflowParam: {
    name: workflowName,
    version
  },
  type: "SUB_WORKFLOW" /* SUB_WORKFLOW */
});

// src/core/sdk/switch.ts
var switchTask = (taskReferenceName, expression, decisionCases = {}, defaultCase = []) => ({
  name: taskReferenceName,
  taskReferenceName,
  decisionCases,
  evaluatorType: "value-param",
  inputParameters: {
    switchCaseValue: expression
  },
  expression: "switchCaseValue",
  defaultCase,
  type: "SWITCH" /* SWITCH */
});

// src/core/sdk/terminate.ts
var terminateTask = (taskReferenceName, status, terminationReason) => ({
  name: taskReferenceName,
  taskReferenceName,
  inputParameters: {
    terminationStatus: status,
    terminationReason
  },
  type: "TERMINATE" /* TERMINATE */
});

// src/core/sdk/wait.ts
var waitTaskDuration = (taskReferenceName, duration) => ({
  name: taskReferenceName,
  taskReferenceName,
  inputParameters: {
    duration
  },
  type: "WAIT" /* WAIT */
});
var waitTaskUntil = (taskReferenceName, until) => ({
  name: taskReferenceName,
  taskReferenceName,
  inputParameters: {
    until
  },
  type: "WAIT" /* WAIT */
});

// src/core/sdk/workflow.ts
var workflow = (name, tasks) => ({
  name,
  version: 1,
  tasks,
  inputParameters: [],
  timeoutSeconds: 0
});

// src/orkes/request/fetchCatchDns/DnsResolver.ts
var import_dns = require("dns");
var DEFAULT_OPTIONS = {
  logger: noopLogger,
  resolver: import_dns.promises.resolve4
};
var dnsResolver = async (host, { resolver = import_dns.promises.resolve4, logger = console } = DEFAULT_OPTIONS) => {
  try {
    const addresses = await resolver(host);
    if (addresses.length > 0)
      return addresses[0];
  } catch (e) {
    logger.error("Could not resolve host: " + host + " error: " + e);
  }
  return void 0;
};

// src/orkes/request/fetchCatchDns/DnsCache.ts
var DnsCacheResolver = class {
  constructor({ initialCache = /* @__PURE__ */ new Map() } = {}) {
    this._cache = /* @__PURE__ */ new Map();
    this._cache = initialCache;
  }
  async resolve(host) {
    const cachedIp = this._cache.get(host);
    if (cachedIp) {
      return cachedIp;
    }
    const ip = await dnsResolver(host);
    if (ip != void 0) {
      this._cache.set(host, ip);
    }
    return ip;
  }
  clearCache() {
    this._cache.clear();
  }
  removeCache(host) {
    this._cache.delete(host);
  }
  get cache() {
    return this._cache;
  }
};

// src/orkes/request/fetchCatchDns/fetchCatchDns.ts
var import_net = require("net");
var isEmpty = (value) => {
  return value === void 0 || value.trim().length === 0;
};
var toMaybeUrl = (originalUrl, modifiedParams) => {
  const urlToHit = new URL(originalUrl.toString());
  urlToHit.host = isEmpty(modifiedParams.port) ? `${modifiedParams.host}:${modifiedParams.port}` : modifiedParams.host;
  return urlToHit;
};
var DEFAULT_OPTIONS2 = {
  dnsCache: new DnsCacheResolver(),
  headerFactory: (headers) => new Headers(headers || {})
};
var fetchCatchDns = (fetch3, {
  dnsCache = new DnsCacheResolver(),
  headerFactory = (headers) => new Headers(headers || {})
} = DEFAULT_OPTIONS2) => {
  const fetchWithDns = async (input, options) => {
    const parsedUrl = new URL(input.toString());
    const { hostname, host, port } = parsedUrl;
    if ((0, import_net.isIP)(hostname)) {
      return await fetch3(input, options);
    }
    const maybeTargetIp = await dnsCache.resolve(hostname);
    if (isEmpty(maybeTargetIp)) {
      return await fetch3(input, options);
    }
    const target = toMaybeUrl(input, {
      ...parsedUrl,
      host: maybeTargetIp,
      port
    });
    const headersOverride = headerFactory(options?.headers ?? {});
    if (!headersOverride.has("Host")) {
      headersOverride.set("Host", host);
    }
    const optionsOverride = {
      ...options,
      headers: headersOverride
    };
    try {
      const res = await fetch3(target.toString(), optionsOverride);
      return res;
    } catch (e) {
      if (e && e?.code === "ETIMEDOUT") {
        dnsCache.removeCache(hostname);
      }
      throw e;
    }
  };
  return fetchWithDns;
};

// src/orkes/request/request.ts
var isDefined2 = (value) => {
  return value !== void 0 && value !== null;
};
var isString2 = (value) => {
  return typeof value === "string";
};
var isStringWithValue2 = (value) => {
  return isString2(value) && value !== "";
};
var isBlob2 = (value) => {
  return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
var isFormData2 = (value) => {
  return value instanceof FormData;
};
var base642 = (str) => {
  try {
    return btoa(str);
  } catch (err) {
    return Buffer.from(str).toString("base64");
  }
};
var getQueryString2 = (params) => {
  const qs = [];
  const append = (key, value) => {
    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
  };
  const process = (key, value) => {
    if (isDefined2(value)) {
      if (Array.isArray(value)) {
        value.forEach((v) => {
          process(key, v);
        });
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([k, v]) => {
          process(`${key}[${k}]`, v);
        });
      } else {
        append(key, value);
      }
    }
  };
  Object.entries(params).forEach(([key, value]) => {
    process(key, value);
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
};
var getUrl2 = (config, options) => {
  const encoder = config.ENCODE_PATH || encodeURI;
  const path = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {
    if (options.path?.hasOwnProperty(group)) {
      return encoder(String(options.path[group]));
    }
    return substring;
  });
  const url = `${config.BASE}${path}`;
  if (options.query) {
    return `${url}${getQueryString2(options.query)}`;
  }
  return url;
};
var getFormData2 = (options) => {
  if (options.formData) {
    const formData = new FormData();
    const process = (key, value) => {
      if (isString2(value) || isBlob2(value)) {
        formData.append(key, value);
      } else {
        formData.append(key, JSON.stringify(value));
      }
    };
    Object.entries(options.formData).filter(([_, value]) => isDefined2(value)).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => process(key, v));
      } else {
        process(key, value);
      }
    });
    return formData;
  }
  return void 0;
};
var resolve2 = async (options, resolver) => {
  if (typeof resolver === "function") {
    return resolver(options);
  }
  return resolver;
};
var getHeaders2 = async (config, options) => {
  const token = await resolve2(options, config.TOKEN);
  const username = await resolve2(options, config.USERNAME);
  const password = await resolve2(options, config.PASSWORD);
  const additionalHeaders = await resolve2(options, config.HEADERS);
  const headers = Object.entries({
    Accept: "application/json",
    ...additionalHeaders,
    ...options.headers
  }).filter(([_, value]) => isDefined2(value)).reduce(
    (headers2, [key, value]) => ({
      ...headers2,
      [key]: String(value)
    }),
    {}
  );
  if (isStringWithValue2(token)) {
    headers["X-AUTHORIZATION"] = token;
  }
  if (isStringWithValue2(username) && isStringWithValue2(password)) {
    const credentials = base642(`${username}:${password}`);
    headers["Authorization"] = `Basic ${credentials}`;
  }
  if (options.body) {
    if (options.mediaType) {
      headers["Content-Type"] = options.mediaType;
    } else if (isBlob2(options.body)) {
      headers["Content-Type"] = "application/octet-stream";
    } else if (isString2(options.body)) {
      headers["Content-Type"] = "text/plain";
    } else if (!isFormData2(options.body)) {
      headers["Content-Type"] = "application/json";
    }
  }
  return new Headers(headers);
};
var getRequestBody2 = (options) => {
  if (options.body) {
    if (options.mediaType?.includes("/json")) {
      return JSON.stringify(options.body);
    } else if (isString2(options.body) || isBlob2(options.body) || isFormData2(options.body)) {
      return options.body;
    } else {
      return JSON.stringify(options.body);
    }
  }
  return void 0;
};
var sendRequest2 = async (options, url, body, formData, headers, onCancel, fetchFn = fetch) => {
  const controller = new AbortController();
  const request3 = {
    headers,
    method: options.method,
    body: body ?? formData,
    signal: controller.signal
  };
  onCancel(() => controller.abort());
  return await fetchFn(url, request3);
};
var getResponseHeader2 = (response, responseHeader) => {
  if (responseHeader) {
    const content = response.headers.get(responseHeader);
    if (isString2(content)) {
      return content;
    }
  }
  return void 0;
};
var getResponseBody2 = async (response) => {
  if (response.status !== 204) {
    try {
      const contentType = response.headers.get("Content-Type");
      if (contentType) {
        const isJSON = contentType.toLowerCase().startsWith("application/json");
        if (isJSON) {
          return await response.json();
        } else {
          return await response.text();
        }
      }
    } catch (error) {
      console.error(error);
    }
  }
  return void 0;
};
var catchErrorCodes2 = (options, result) => {
  const errors = {
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    502: "Bad Gateway",
    503: "Service Unavailable",
    ...options.errors
  };
  const error = errors[result.status];
  if (error) {
    throw new ApiError(options, result, error);
  }
  if (!result.ok) {
    throw new ApiError(options, result, "Generic Error");
  }
};
var request2 = (config, options, fetchFn = fetch) => {
  return new CancelablePromise(async (resolve3, reject, onCancel) => {
    try {
      const url = getUrl2(config, options);
      const formData = getFormData2(options);
      const body = getRequestBody2(options);
      const headers = await getHeaders2(config, options);
      if (!onCancel.isCancelled) {
        const response = await sendRequest2(
          options,
          url,
          body,
          formData,
          headers,
          onCancel,
          fetchFn
        );
        const responseBody = await getResponseBody2(response);
        const responseHeader = getResponseHeader2(
          response,
          options.responseHeader
        );
        const result = {
          url,
          ok: response.ok,
          status: response.status,
          statusText: response.statusText,
          body: responseHeader ?? responseBody
        };
        catchErrorCodes2(options, result);
        resolve3(result.body);
      }
    } catch (error) {
      reject(error);
    }
  });
};

// src/orkes/BaseOrkesConductorClient.ts
var defaultRequestHandler2 = (request3, config, options) => request3(config, options);
var REFRESH_TOKEN_IN_MILLISECONDS = 30 * 60 * 1e3;
var AuthConductorClient = class extends ConductorClient {
  constructor(config, requestHandler = defaultRequestHandler2) {
    super(config, requestHandler);
  }
  /**
   * Stops the interval that refreshes the token
   */
  stop() {
    if (this.intervalId != null) {
      clearInterval(this.intervalId);
    }
  }
};
var baseOrkesConductorClient = (fetchFn, baseRequestHandler = defaultRequestHandler2) => {
  const requestTokenForKeySecret = (keyId, keySecret, tokenUrl) => fetchFn(tokenUrl, {
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    },
    body: JSON.stringify({ keyId, keySecret }),
    method: "POST"
  });
  return async (config, requestHandler = baseRequestHandler) => {
    if (config?.keySecret != null && config?.keyId != null) {
      const {
        serverUrl,
        keyId,
        keySecret,
        refreshTokenInterval = REFRESH_TOKEN_IN_MILLISECONDS
      } = config;
      const tokenUrl = `${serverUrl}/token`;
      const res = await requestTokenForKeySecret(keyId, keySecret, tokenUrl);
      const { token } = await res.json();
      const conductorClientInstance = new AuthConductorClient(
        { ...config, TOKEN: token },
        requestHandler
      );
      if (token != null && refreshTokenInterval > 0) {
        const intervalId = setInterval(async () => {
          const res2 = await requestTokenForKeySecret(
            keyId,
            keySecret,
            tokenUrl
          );
          const { token: token2 } = await res2.json();
          conductorClientInstance.token = token2;
        }, refreshTokenInterval);
        conductorClientInstance.intervalId = intervalId;
      }
      return conductorClientInstance;
    } else {
      return new ConductorClient(config, requestHandler);
    }
  };
};

// src/orkes/OrkesConductorClient.ts
var import_node_fetch = __toESM(require("node-fetch"));
var import_http = __toESM(require("http"));
var import_https = __toESM(require("https"));
var httpAgent = new import_http.default.Agent({ keepAlive: true });
var httpsAgent = new import_https.default.Agent({ keepAlive: true });
var agent = (_parsedURL) => _parsedURL.protocol == "http:" ? httpAgent : httpsAgent;
var nodeFetchWrapper = async (input, options = {}) => {
  const res = await (0, import_node_fetch.default)(input.toString(), {
    ...options,
    agent
  });
  return res;
};
var fetchCache = fetchCatchDns(
  nodeFetchWrapper,
  {
    //@ts-ignore
    headerFactory: (headers) => new import_node_fetch.Headers(headers || {})
  }
);
var defaultRequestHandler3 = (__request, config, options) => request2(config, options, fetchCache);
var orkesConductorClient = baseOrkesConductorClient(
  fetchCache,
  defaultRequestHandler3
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApiError,
  AuthConductorClient,
  BaseHttpRequest,
  CancelError,
  CancelablePromise,
  ConductorClient,
  ConductorError,
  DefaultLogger,
  DnsCacheResolver,
  EventResourceService,
  HealthCheckResourceService,
  HumanExecutor,
  MetadataResourceService,
  SchedulerResourceService,
  TaskManager,
  TaskResourceService,
  TaskRunner,
  TaskType,
  TokenResourceService,
  WorkflowBulkResourceService,
  WorkflowExecutor,
  WorkflowResourceService,
  baseOrkesConductorClient,
  conductorEventTask,
  doWhileTask,
  dynamicForkTask,
  eventTask,
  fetchCatchDns,
  forkTask,
  forkTaskJoin,
  generate,
  generateDoWhileTask,
  generateEventTask,
  generateForkJoinTask,
  generateHTTPTask,
  generateInlineTask,
  generateJQTransformTask,
  generateJoinTask,
  generateKafkaPublishTask,
  generateSetVariableTask,
  generateSimpleTask,
  generateSubWorkflowTask,
  generateSwitchTask,
  generateTerminateTask,
  generateWaitTask,
  httpTask,
  inlineTask,
  joinTask,
  jsonJqTask,
  kafkaPublishTask,
  newLoopTask,
  noopErrorHandler,
  noopLogger,
  orkesConductorClient,
  request,
  setVariableTask,
  simpleTask,
  sqsEventTask,
  subWorkflowTask,
  switchTask,
  taskGenMapper,
  terminateTask,
  toMaybeUrl,
  waitTaskDuration,
  waitTaskUntil,
  workflow
});
//# sourceMappingURL=index.js.map