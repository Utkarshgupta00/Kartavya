declare type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
};

declare class CancelError extends Error {
    constructor(message: string);
    get isCancelled(): boolean;
}
interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;
    (cancelHandler: () => void): void;
}
declare class CancelablePromise<T> implements Promise<T> {
    readonly [Symbol.toStringTag]: string;
    private _isResolved;
    private _isRejected;
    private _isCancelled;
    private readonly _cancelHandlers;
    private readonly _promise;
    private _resolve?;
    private _reject?;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancel) => void);
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | null): Promise<T>;
    cancel(): void;
    get isCancelled(): boolean;
}

declare type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
declare type Headers$1 = Record<string, string>;
declare type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    CREDENTIALS: 'include' | 'omit' | 'same-origin';
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers$1 | Resolver<Headers$1>;
    ENCODE_PATH?: (path: string) => string;
};

declare abstract class BaseHttpRequest {
    readonly config: OpenAPIConfig;
    constructor(config: OpenAPIConfig);
    abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}

declare type StartWorkflow = {
    name?: string;
    version?: number;
    correlationId?: string;
    input?: Record<string, any>;
    taskToDomain?: Record<string, string>;
};

declare type TaskDetails = {
    workflowId?: string;
    taskRefName?: string;
    output?: Record<string, any>;
    taskId?: string;
};

declare type Action = {
    action?: 'start_workflow' | 'complete_task' | 'fail_task';
    start_workflow?: StartWorkflow;
    complete_task?: TaskDetails;
    fail_task?: TaskDetails;
    expandInlineJSON?: boolean;
};

declare type EventHandler = {
    name: string;
    event: string;
    condition?: string;
    actions: Array<Action>;
    active?: boolean;
    evaluatorType?: string;
};

declare class EventResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get queue config by name
     * @param queueType
     * @param queueName
     * @returns any OK
     * @throws ApiError
     */
    getQueueConfig(queueType: string, queueName: string): CancelablePromise<any>;
    /**
     * Create or update queue config by name
     * @param queueType
     * @param queueName
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    putQueueConfig(queueType: string, queueName: string, requestBody: string): CancelablePromise<any>;
    /**
     * Delete queue config by name
     * @param queueType
     * @param queueName
     * @returns any OK
     * @throws ApiError
     */
    deleteQueueConfig(queueType: string, queueName: string): CancelablePromise<any>;
    /**
     * Get all the event handlers
     * @returns EventHandler OK
     * @throws ApiError
     */
    getEventHandlers(): CancelablePromise<Array<EventHandler>>;
    /**
     * Update an existing event handler.
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    updateEventHandler(requestBody: EventHandler): CancelablePromise<any>;
    /**
     * Add a new event handler.
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    addEventHandler(requestBody: EventHandler): CancelablePromise<any>;
    /**
     * Get all queue configs
     * @returns any OK
     * @throws ApiError
     */
    getQueueNames(): CancelablePromise<any>;
    /**
     * Remove an event handler
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    removeEventHandlerStatus(name: string): CancelablePromise<any>;
    /**
     * Get event handlers for a given event
     * @param event
     * @param activeOnly
     * @returns EventHandler OK
     * @throws ApiError
     */
    getEventHandlersForEvent(event: string, activeOnly?: boolean): CancelablePromise<Array<EventHandler>>;
}

declare class HealthCheckResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * @returns any OK
     * @throws ApiError
     */
    doCheck(): CancelablePromise<Record<string, any>>;
}

declare type TaskDef = {
    ownerApp?: string;
    createTime?: number;
    updateTime?: number;
    createdBy?: string;
    updatedBy?: string;
    name: string;
    description?: string;
    retryCount?: number;
    timeoutSeconds: number;
    inputKeys?: Array<string>;
    outputKeys?: Array<string>;
    timeoutPolicy?: 'RETRY' | 'TIME_OUT_WF' | 'ALERT_ONLY';
    retryLogic?: 'FIXED' | 'EXPONENTIAL_BACKOFF' | 'LINEAR_BACKOFF';
    retryDelaySeconds?: number;
    responseTimeoutSeconds?: number;
    concurrentExecLimit?: number;
    inputTemplate?: Record<string, any>;
    rateLimitPerFrequency?: number;
    rateLimitFrequencyInSeconds?: number;
    isolationGroupId?: string;
    executionNameSpace?: string;
    ownerEmail?: string;
    pollTimeoutSeconds?: number;
    backoffScaleFactor?: number;
};

declare type SubWorkflowParams = {
    name: string;
    version?: number;
    taskToDomain?: Record<string, string>;
    workflowDefinition?: WorkflowDef$1;
};

declare type WorkflowTask = {
    name: string;
    taskReferenceName: string;
    description?: string;
    inputParameters?: Record<string, any>;
    type?: string;
    dynamicTaskNameParam?: string;
    /**
     * @deprecated
     */
    caseValueParam?: string;
    /**
     * @deprecated
     */
    caseExpression?: string;
    scriptExpression?: string;
    decisionCases?: Record<string, Array<WorkflowTask>>;
    /**
     * @deprecated
     */
    dynamicForkJoinTasksParam?: string;
    dynamicForkTasksParam?: string;
    dynamicForkTasksInputParamName?: string;
    defaultCase?: Array<WorkflowTask>;
    forkTasks?: Array<Array<WorkflowTask>>;
    startDelay?: number;
    subWorkflowParam?: SubWorkflowParams;
    joinOn?: Array<string>;
    sink?: string;
    optional?: boolean;
    taskDefinition?: TaskDef;
    rateLimited?: boolean;
    defaultExclusiveJoinTask?: Array<string>;
    asyncComplete?: boolean;
    loopCondition?: string;
    loopOver?: Array<WorkflowTask>;
    retryCount?: number;
    evaluatorType?: string;
    expression?: string;
    workflowTaskType?: 'SIMPLE' | 'DYNAMIC' | 'FORK_JOIN' | 'FORK_JOIN_DYNAMIC' | 'DECISION' | 'SWITCH' | 'JOIN' | 'DO_WHILE' | 'SUB_WORKFLOW' | 'START_WORKFLOW' | 'EVENT' | 'WAIT' | 'HUMAN' | 'USER_DEFINED' | 'HTTP' | 'LAMBDA' | 'INLINE' | 'EXCLUSIVE_JOIN' | 'TERMINATE' | 'KAFKA_PUBLISH' | 'JSON_JQ_TRANSFORM' | 'SET_VARIABLE';
};

declare type WorkflowDef$1 = {
    ownerApp?: string;
    createTime?: number;
    updateTime?: number;
    createdBy?: string;
    updatedBy?: string;
    name: string;
    description?: string;
    version?: number;
    tasks: Array<WorkflowTask>;
    inputParameters?: Array<string>;
    outputParameters?: Record<string, any>;
    failureWorkflow?: string;
    schemaVersion?: number;
    restartable?: boolean;
    workflowStatusListenerEnabled?: boolean;
    ownerEmail?: string;
    timeoutPolicy?: 'TIME_OUT_WF' | 'ALERT_ONLY';
    timeoutSeconds: number;
    variables?: Record<string, any>;
    inputTemplate?: Record<string, any>;
};

declare class MetadataResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Gets the task definition
     * @param tasktype
     * @param metadata
     * @returns TaskDef OK
     * @throws ApiError
     */
    getTaskDef(tasktype: string, metadata?: boolean): CancelablePromise<TaskDef>;
    /**
     * Remove a task definition
     * @param tasktype
     * @returns any OK
     * @throws ApiError
     */
    unregisterTaskDef(tasktype: string): CancelablePromise<any>;
    /**
     * Retrieves all workflow definition along with blueprint
     * @param access
     * @param metadata
     * @param tagKey
     * @param tagValue
     * @returns WorkflowDef OK
     * @throws ApiError
     */
    getAllWorkflows(access?: string, metadata?: boolean, tagKey?: string, tagValue?: string): CancelablePromise<Array<WorkflowDef$1>>;
    /**
     * Create or update workflow definition(s)
     * @param requestBody
     * @param overwrite
     * @returns any OK
     * @throws ApiError
     */
    update(requestBody: Array<WorkflowDef$1>, overwrite?: boolean): CancelablePromise<any>;
    /**
     * Create a new workflow definition
     * @param requestBody
     * @param overwrite
     * @returns any OK
     * @throws ApiError
     */
    create(requestBody: WorkflowDef$1, overwrite?: boolean): CancelablePromise<any>;
    /**
     * Gets all task definition
     * @param access
     * @param metadata
     * @param tagKey
     * @param tagValue
     * @returns TaskDef OK
     * @throws ApiError
     */
    getTaskDefs(access?: string, metadata?: boolean, tagKey?: string, tagValue?: string): CancelablePromise<Array<TaskDef>>;
    /**
     * Update an existing task
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    updateTaskDef(requestBody: TaskDef): CancelablePromise<any>;
    /**
     * Create or update task definition(s)
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    registerTaskDef(requestBody: Array<TaskDef>): CancelablePromise<any>;
    /**
     * Removes workflow definition. It does not remove workflows associated with the definition.
     * @param name
     * @param version
     * @returns any OK
     * @throws ApiError
     */
    unregisterWorkflowDef(name: string, version: number): CancelablePromise<any>;
    /**
     * Retrieves workflow definition along with blueprint
     * @param name
     * @param version
     * @param metadata
     * @returns WorkflowDef OK
     * @throws ApiError
     */
    get(name: string, version?: number, metadata?: boolean): CancelablePromise<WorkflowDef$1>;
}

declare type StartWorkflowRequest = {
    name: string;
    version?: number;
    correlationId?: string;
    input?: Record<string, any>;
    taskToDomain?: Record<string, string>;
    workflowDef?: WorkflowDef$1;
    externalInputPayloadStoragePath?: string;
    priority?: number;
    createdBy?: string;
};

declare type SaveScheduleRequest = {
    name: string;
    cronExpression: string;
    runCatchupScheduleInstances?: boolean;
    paused?: boolean;
    startWorkflowRequest?: StartWorkflowRequest;
    createdBy?: string;
    updatedBy?: string;
    scheduleStartTime?: number;
    scheduleEndTime?: number;
};

declare type WorkflowScheduleExecutionModel = {
    executionId?: string;
    scheduleName?: string;
    scheduledTime?: number;
    executionTime?: number;
    workflowName?: string;
    workflowId?: string;
    reason?: string;
    stackTrace?: string;
    startWorkflowRequest?: StartWorkflowRequest;
    state?: 'POLLED' | 'FAILED' | 'EXECUTED';
};

declare type SearchResultWorkflowScheduleExecutionModel = {
    totalHits?: number;
    results?: Array<WorkflowScheduleExecutionModel>;
};

declare type WorkflowSchedule = {
    name?: string;
    cronExpression?: string;
    runCatchupScheduleInstances?: boolean;
    paused?: boolean;
    startWorkflowRequest?: StartWorkflowRequest;
    scheduleStartTime?: number;
    scheduleEndTime?: number;
    createTime?: number;
    updatedTime?: number;
    createdBy?: string;
    updatedBy?: string;
};

declare class SchedulerResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get an existing workflow schedule by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    getSchedule(name: string): CancelablePromise<any>;
    /**
     * Deletes an existing workflow schedule by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    deleteSchedule(name: string): CancelablePromise<any>;
    /**
     * Get list of the next x (default 3, max 5) execution times for a scheduler
     * @param cronExpression
     * @param scheduleStartTime
     * @param scheduleEndTime
     * @param limit
     * @returns number OK
     * @throws ApiError
     */
    getNextFewSchedules(cronExpression: string, scheduleStartTime?: number, scheduleEndTime?: number, limit?: number): CancelablePromise<Array<number>>;
    /**
     * Pauses an existing schedule by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    pauseSchedule(name: string): CancelablePromise<any>;
    /**
     * Pause all scheduling in a single conductor server instance (for debugging only)
     * @returns any OK
     * @throws ApiError
     */
    pauseAllSchedules(): CancelablePromise<Record<string, any>>;
    /**
     * Resume a paused schedule by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    resumeSchedule(name: string): CancelablePromise<any>;
    /**
     * Requeue all execution records
     * @returns any OK
     * @throws ApiError
     */
    requeueAllExecutionRecords(): CancelablePromise<Record<string, any>>;
    /**
     * Resume all scheduling
     * @returns any OK
     * @throws ApiError
     */
    resumeAllSchedules(): CancelablePromise<Record<string, any>>;
    /**
     * Get all existing workflow schedules and optionally filter by workflow name
     * @param workflowName
     * @returns WorkflowSchedule OK
     * @throws ApiError
     */
    getAllSchedules(workflowName?: string): CancelablePromise<Array<WorkflowSchedule>>;
    /**
     * Create or update a schedule for a specified workflow with a corresponding start workflow request
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    saveSchedule(requestBody: SaveScheduleRequest): CancelablePromise<any>;
    /**
     * Test timeout - do not use in production
     * @returns any OK
     * @throws ApiError
     */
    testTimeout(): CancelablePromise<any>;
    /**
     * Search for workflows based on payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflowScheduleExecutionModel OK
     * @throws ApiError
     */
    searchV21(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultWorkflowScheduleExecutionModel>;
}

declare type ExternalStorageLocation = {
    uri?: string;
    path?: string;
};

declare type PollData = {
    queueName?: string;
    domain?: string;
    workerId?: string;
    lastPollTime?: number;
};

declare type Task = {
    taskType?: string;
    status?: 'IN_PROGRESS' | 'CANCELED' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED' | 'COMPLETED_WITH_ERRORS' | 'SCHEDULED' | 'TIMED_OUT' | 'SKIPPED';
    inputData?: Record<string, any>;
    referenceTaskName?: string;
    retryCount?: number;
    seq?: number;
    correlationId?: string;
    pollCount?: number;
    taskDefName?: string;
    scheduledTime?: number;
    startTime?: number;
    endTime?: number;
    updateTime?: number;
    startDelayInSeconds?: number;
    retriedTaskId?: string;
    retried?: boolean;
    executed?: boolean;
    callbackFromWorker?: boolean;
    responseTimeoutSeconds?: number;
    workflowInstanceId?: string;
    workflowType?: string;
    taskId?: string;
    reasonForIncompletion?: string;
    callbackAfterSeconds?: number;
    workerId?: string;
    outputData?: Record<string, any>;
    workflowTask?: WorkflowTask;
    domain?: string;
    rateLimitPerFrequency?: number;
    rateLimitFrequencyInSeconds?: number;
    externalInputPayloadStoragePath?: string;
    externalOutputPayloadStoragePath?: string;
    workflowPriority?: number;
    executionNameSpace?: string;
    isolationGroupId?: string;
    iteration?: number;
    subWorkflowId?: string;
    subworkflowChanged?: boolean;
    queueWaitTime?: number;
    taskDefinition?: TaskDef;
    loopOverTask?: boolean;
};

declare type SearchResultTask = {
    totalHits?: number;
    results?: Array<Task>;
};

declare type TaskSummary = {
    workflowId?: string;
    workflowType?: string;
    correlationId?: string;
    scheduledTime?: string;
    startTime?: string;
    updateTime?: string;
    endTime?: string;
    status?: 'IN_PROGRESS' | 'CANCELED' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED' | 'COMPLETED_WITH_ERRORS' | 'SCHEDULED' | 'TIMED_OUT' | 'SKIPPED';
    reasonForIncompletion?: string;
    executionTime?: number;
    queueWaitTime?: number;
    taskDefName?: string;
    taskType?: string;
    input?: string;
    output?: string;
    taskId?: string;
    externalInputPayloadStoragePath?: string;
    externalOutputPayloadStoragePath?: string;
    workflowPriority?: number;
};

declare type SearchResultTaskSummary = {
    totalHits?: number;
    results?: Array<TaskSummary>;
};

declare type TaskExecLog = {
    log?: string;
    taskId?: string;
    createdTime?: number;
};

declare type TaskResult = {
    workflowInstanceId: string;
    taskId: string;
    reasonForIncompletion?: string;
    callbackAfterSeconds?: number;
    workerId?: string;
    status?: 'IN_PROGRESS' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED';
    outputData?: Record<string, any>;
    logs?: Array<TaskExecLog>;
    externalOutputPayloadStoragePath?: string;
    subWorkflowId?: string;
};

declare class TaskResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Poll for a task of a certain type
     * @param tasktype
     * @param workerid
     * @param domain
     * @returns Task OK
     * @throws ApiError
     */
    poll(tasktype: string, workerid?: string, domain?: string): CancelablePromise<Task>;
    /**
     * Get the details about each queue
     * @returns number OK
     * @throws ApiError
     */
    allVerbose(): CancelablePromise<Record<string, Record<string, Record<string, number>>>>;
    /**
     * Update a task By Ref Name
     * @param workflowId
     * @param taskRefName
     * @param status
     * @param requestBody
     * @returns string OK
     * @throws ApiError
     */
    updateTask(workflowId: string, taskRefName: string, status: 'IN_PROGRESS' | 'FAILED' | 'FAILED_WITH_TERMINAL_ERROR' | 'COMPLETED', requestBody: Record<string, any>): CancelablePromise<string>;
    /**
     * Get task by Id
     * @param taskId
     * @returns Task OK
     * @throws ApiError
     */
    getTask(taskId: string): CancelablePromise<Task>;
    /**
     * Get the details about each queue
     * @returns number OK
     * @throws ApiError
     */
    all(): CancelablePromise<Record<string, number>>;
    /**
     * Requeue pending tasks
     * @param taskType
     * @returns string OK
     * @throws ApiError
     */
    requeuePendingTask(taskType: string): CancelablePromise<string>;
    /**
     * Search for tasks based in payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultTaskSummary OK
     * @throws ApiError
     */
    search(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultTaskSummary>;
    /**
     * Search for tasks based in payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultTask OK
     * @throws ApiError
     */
    searchV22(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultTask>;
    /**
     * Get the last poll data for a given task type
     * @param taskType
     * @returns PollData OK
     * @throws ApiError
     */
    getPollData(taskType: string): CancelablePromise<Array<PollData>>;
    /**
     * Get Task Execution Logs
     * @param taskId
     * @returns TaskExecLog OK
     * @throws ApiError
     */
    getTaskLogs(taskId: string): CancelablePromise<Array<TaskExecLog>>;
    /**
     * Log Task Execution Details
     * @param taskId
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    log(taskId: string, requestBody: string): CancelablePromise<any>;
    /**
     * Get the last poll data for all task types
     * @returns PollData OK
     * @throws ApiError
     */
    getAllPollData(): CancelablePromise<Array<PollData>>;
    /**
     * Batch poll for a task of a certain type
     * @param tasktype
     * @param workerid
     * @param domain
     * @param count
     * @param timeout
     * @returns Task OK
     * @throws ApiError
     */
    batchPoll(tasktype: string, workerid?: string, domain?: string, count?: number, timeout?: number): CancelablePromise<Array<Task>>;
    /**
     * Update a task
     * @param requestBody
     * @returns string OK
     * @throws ApiError
     */
    updateTask1(requestBody: TaskResult): CancelablePromise<string>;
    /**
     * Get Task type queue sizes
     * @param taskType
     * @returns number OK
     * @throws ApiError
     */
    size1(taskType?: Array<string>): CancelablePromise<Record<string, number>>;
    /**
     * Get the external uri where the task payload is to be stored
     * @param path
     * @param operation
     * @param payloadType
     * @returns ExternalStorageLocation OK
     * @throws ApiError
     */
    getExternalStorageLocation1(path: string, operation: string, payloadType: string): CancelablePromise<ExternalStorageLocation>;
}

declare type GenerateTokenRequest = {
    keyId: string;
    keySecret: string;
    refreshTokenInterval?: number;
};

declare type Response$1 = {};

declare class TokenResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Generate JWT with the given access key
     * @param requestBody
     * @returns Response OK
     * @throws ApiError
     */
    generateToken(requestBody: GenerateTokenRequest): CancelablePromise<Response$1>;
    /**
     * Get the user info from the token
     * @returns any OK
     * @throws ApiError
     */
    getUserInfo(): CancelablePromise<any>;
}

declare type BulkResponse = {
    bulkErrorResults?: Record<string, string>;
    bulkSuccessfulResults?: Array<string>;
};

declare class WorkflowBulkResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Retry the last failed task for each workflow from the list
     * @param requestBody
     * @returns BulkResponse OK
     * @throws ApiError
     */
    retry(requestBody: Array<string>): CancelablePromise<BulkResponse>;
    /**
     * Restart the list of completed workflow
     * @param requestBody
     * @param useLatestDefinitions
     * @returns BulkResponse OK
     * @throws ApiError
     */
    restart(requestBody: Array<string>, useLatestDefinitions?: boolean): CancelablePromise<BulkResponse>;
    /**
     * Terminate workflows execution
     * @param requestBody
     * @param reason
     * @returns BulkResponse OK
     * @throws ApiError
     */
    terminate(requestBody: Array<string>, reason?: string): CancelablePromise<BulkResponse>;
    /**
     * Resume the list of workflows
     * @param requestBody
     * @returns BulkResponse OK
     * @throws ApiError
     */
    resumeWorkflow(requestBody: Array<string>): CancelablePromise<BulkResponse>;
    /**
     * Pause the list of workflows
     * @param requestBody
     * @returns BulkResponse OK
     * @throws ApiError
     */
    pauseWorkflow1(requestBody: Array<string>): CancelablePromise<BulkResponse>;
}

declare type RerunWorkflowRequest = {
    reRunFromWorkflowId?: string;
    workflowInput?: Record<string, any>;
    reRunFromTaskId?: string;
    taskInput?: Record<string, any>;
    correlationId?: string;
};

declare type WorkflowSummary = {
    workflowType?: string;
    version?: number;
    workflowId?: string;
    correlationId?: string;
    startTime?: string;
    updateTime?: string;
    endTime?: string;
    status?: 'RUNNING' | 'COMPLETED' | 'FAILED' | 'TIMED_OUT' | 'TERMINATED' | 'PAUSED';
    input?: string;
    output?: string;
    reasonForIncompletion?: string;
    executionTime?: number;
    event?: string;
    failedReferenceTaskNames?: string;
    externalInputPayloadStoragePath?: string;
    externalOutputPayloadStoragePath?: string;
    priority?: number;
    createdBy?: string;
    outputSize?: number;
    inputSize?: number;
};

declare type ScrollableSearchResultWorkflowSummary = {
    results?: Array<WorkflowSummary>;
    queryId?: string;
};

declare type Workflow = {
    ownerApp?: string;
    createTime?: number;
    updateTime?: number;
    createdBy?: string;
    updatedBy?: string;
    status?: 'RUNNING' | 'COMPLETED' | 'FAILED' | 'TIMED_OUT' | 'TERMINATED' | 'PAUSED';
    endTime?: number;
    workflowId?: string;
    parentWorkflowId?: string;
    parentWorkflowTaskId?: string;
    tasks?: Array<Task>;
    input?: Record<string, any>;
    output?: Record<string, any>;
    correlationId?: string;
    reRunFromWorkflowId?: string;
    reasonForIncompletion?: string;
    event?: string;
    taskToDomain?: Record<string, string>;
    failedReferenceTaskNames?: Array<string>;
    workflowDefinition?: WorkflowDef$1;
    externalInputPayloadStoragePath?: string;
    externalOutputPayloadStoragePath?: string;
    priority?: number;
    variables?: Record<string, any>;
    lastRetriedTime?: number;
    startTime?: number;
    workflowVersion?: number;
    workflowName?: string;
};

declare type SearchResultWorkflow = {
    totalHits?: number;
    results?: Array<Workflow>;
};

declare type SearchResultWorkflowSummary = {
    totalHits?: number;
    results?: Array<WorkflowSummary>;
};

declare type SkipTaskRequest = {
    taskInput?: Record<string, any>;
    taskOutput?: Record<string, any>;
};

declare type WorkflowRun = {
    correlationId?: string;
    createTime?: number;
    createdBy?: string;
    priority?: number;
    requestId?: string;
    status?: string;
    tasks?: Array<Task>;
    updateTime?: number;
    workflowId?: string;
    variables?: Record<string, object>;
    input?: Record<string, object>;
    output?: Record<string, object>;
};

declare type WorkflowStatus = {
    workflowId?: string;
    correlationId?: string;
    output?: Record<string, any>;
    variables?: Record<string, any>;
    status?: 'RUNNING' | 'COMPLETED' | 'FAILED' | 'TIMED_OUT' | 'TERMINATED' | 'PAUSED';
};

declare class WorkflowResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Retrieve all the running workflows
     * @param name
     * @param version
     * @param startTime
     * @param endTime
     * @returns string OK
     * @throws ApiError
     */
    getRunningWorkflow(name: string, version?: number, startTime?: number, endTime?: number): CancelablePromise<Array<string>>;
    /**
     * Execute a workflow synchronously
     * @param body
     * @param name
     * @param version
     * @param requestId
     * @param waitUntilTaskRef
     * @param callback
     * @returns workflowRun
     * @throws ApiError
     */
    executeWorkflow(body: StartWorkflowRequest, name: string, version: number, requestId: string, waitUntilTaskRef: string): CancelablePromise<WorkflowRun>;
    /**
     * Start a new workflow with StartWorkflowRequest, which allows task to be executed in a domain
     * @param requestBody
     * @returns string OK
     * @throws ApiError
     */
    startWorkflow(requestBody: StartWorkflowRequest): CancelablePromise<string>;
    /**
     * Starts the decision task for a workflow
     * @param workflowId
     * @returns any OK
     * @throws ApiError
     */
    decide(workflowId: string): CancelablePromise<any>;
    /**
     * Reruns the workflow from a specific task
     * @param workflowId
     * @param requestBody
     * @returns string OK
     * @throws ApiError
     */
    rerun(workflowId: string, requestBody: RerunWorkflowRequest): CancelablePromise<string>;
    /**
     * Search for workflows based on payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflow OK
     * @throws ApiError
     */
    searchV21(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultWorkflow>;
    /**
     * Pauses the workflow
     * @param workflowId
     * @returns any OK
     * @throws ApiError
     */
    pauseWorkflow(workflowId: string): CancelablePromise<any>;
    /**
     * Skips a given task from a current running workflow
     * @param workflowId
     * @param taskReferenceName
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    skipTaskFromWorkflow(workflowId: string, taskReferenceName: string, requestBody?: SkipTaskRequest): CancelablePromise<any>;
    /**
     * Lists workflows for the given correlation id list
     * @param name
     * @param requestBody
     * @param includeClosed
     * @param includeTasks
     * @returns Workflow OK
     * @throws ApiError
     */
    getWorkflows(name: string, requestBody: Array<string>, includeClosed?: boolean, includeTasks?: boolean): CancelablePromise<Record<string, Array<Workflow>>>;
    /**
     * Gets the workflow by workflow id
     * @param workflowId
     * @param includeOutput
     * @param includeVariables
     * @returns WorkflowStatus OK
     * @throws ApiError
     */
    getWorkflowStatusSummary(workflowId: string, includeOutput?: boolean, includeVariables?: boolean): CancelablePromise<WorkflowStatus>;
    /**
     * Lists workflows for the given correlation id
     * @param name
     * @param correlationId
     * @param includeClosed
     * @param includeTasks
     * @returns Workflow OK
     * @throws ApiError
     */
    getWorkflows1(name: string, correlationId: string, includeClosed?: boolean, includeTasks?: boolean): CancelablePromise<Array<Workflow>>;
    /**
     * Retries the last failed task
     * @param workflowId
     * @param resumeSubworkflowTasks
     * @returns void
     * @throws ApiError
     */
    retry1(workflowId: string, resumeSubworkflowTasks?: boolean): CancelablePromise<void>;
    /**
     * Gets the workflow by workflow id
     * @param workflowId
     * @param includeTasks
     * @returns Workflow OK
     * @throws ApiError
     */
    getExecutionStatus(workflowId: string, includeTasks?: boolean): CancelablePromise<Workflow>;
    /**
     * Terminate workflow execution
     * @param workflowId
     * @param reason
     * @returns any OK
     * @throws ApiError
     */
    terminate1(workflowId: string, reason?: string): CancelablePromise<any>;
    /**
     * Resumes the workflow
     * @param workflowId
     * @returns any OK
     * @throws ApiError
     */
    resumeWorkflow(workflowId: string): CancelablePromise<any>;
    /**
     * Removes the workflow from the system
     * @param workflowId
     * @param archiveWorkflow
     * @returns any OK
     * @throws ApiError
     */
    delete(workflowId: string, archiveWorkflow?: boolean): CancelablePromise<any>;
    /**
     * Search for workflows based on task parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflowSummary OK
     * @throws ApiError
     */
    searchWorkflowsByTasks(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultWorkflowSummary>;
    /**
     * Get the uri and path of the external storage where the workflow payload is to be stored
     * @param path
     * @param operation
     * @param payloadType
     * @returns ExternalStorageLocation OK
     * @throws ApiError
     */
    getExternalStorageLocation(path: string, operation: string, payloadType: string): CancelablePromise<ExternalStorageLocation>;
    /**
     * Start a new workflow. Returns the ID of the workflow instance that can be later used for tracking
     * @param name
     * @param requestBody
     * @param version
     * @param correlationId
     * @param priority
     * @returns string OK
     * @throws ApiError
     */
    startWorkflow1(name: string, requestBody: Record<string, any>, version?: number, correlationId?: string, priority?: number): CancelablePromise<string>;
    /**
     * Restarts a completed workflow
     * @param workflowId
     * @param useLatestDefinitions
     * @returns void
     * @throws ApiError
     */
    restart1(workflowId: string, useLatestDefinitions?: boolean): CancelablePromise<void>;
    /**
     * Search for workflows based on payload and other parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC.
     * @param queryId
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @param skipCache
     * @returns ScrollableSearchResultWorkflowSummary OK
     * @throws ApiError
     */
    search1(queryId?: string, start?: number, size?: number, sort?: string, freeText?: string, query?: string, skipCache?: boolean): CancelablePromise<ScrollableSearchResultWorkflowSummary>;
    /**
     * Search for workflows based on task parameters
     * use sort options as sort=<field>:ASC|DESC e.g. sort=name&sort=workflowId:DESC. If order is not specified, defaults to ASC
     * @param start
     * @param size
     * @param sort
     * @param freeText
     * @param query
     * @returns SearchResultWorkflow OK
     * @throws ApiError
     */
    searchWorkflowsByTasksV2(start?: number, size?: number, sort?: string, freeText?: string, query?: string): CancelablePromise<SearchResultWorkflow>;
    /**
     * Resets callback times of all non-terminal SIMPLE tasks to 0
     * @param workflowId
     * @returns void
     * @throws ApiError
     */
    resetWorkflow(workflowId: string): CancelablePromise<void>;
}

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
declare const request: <T>(config: OpenAPIConfig, options: ApiRequestOptions) => CancelablePromise<T>;

/**
 * A handler to modify requests made by ConductorClient. Useful for metrics/option transformation/etc.
 *
 * @remarks
 * Example: Customizing the request URL
 * ```
 *
 * const requestCustomizer = (request, config, options) =>  {
 *  const url = options.url.replace(/^\/api/, '')
 *  return request(config, {...options, url });
 * }
 * const config = { BASE: "https://my-api.com"}
 * const client = new ConductorClient(config, requestCustomizer)
 * ```
 *
 * @param request the underlying node-fetch powered function
 * @param config @see OpenAPIConfig
 * @param options {see ApiRequestOptions}
 */
declare type RequestType = typeof request;
declare type ConductorHttpRequest = <T>(request: RequestType, config: OpenAPIConfig, options: ApiRequestOptions) => CancelablePromise<T>;

declare type AssignmentPolicy = {
    type: string;
};

declare type FFAAssignment = AssignmentPolicy;

declare type Fixed = (AssignmentPolicy & {
    assignee?: string;
    assigneeType?: 'EXTERNAL_USER' | 'EXTERNAL_GROUP' | 'CONDUCTOR_USER' | 'CONDUCTOR_GROUP';
});

declare type TimeoutPolicy = {
    type: string;
};

declare type BackToAssigment = (TimeoutPolicy & {
    timeoutSeconds?: number;
});

declare type ClearAssigment = (TimeoutPolicy & {
    timeoutSeconds?: number;
});

declare type Escalate = (TimeoutPolicy & {
    subjects?: Array<string>;
    timeoutSeconds?: number;
} & {
    subjects: Array<string>;
});

declare type LeastBusyGroupMemberAssignment = (AssignmentPolicy & {
    groupId?: string;
});

declare type Never = TimeoutPolicy;

declare type Terminate = (TimeoutPolicy & {
    timeoutSeconds?: number;
});

declare type HumanTaskEntry = {
    assignee?: string;
    assigneeType?: 'EXTERNAL_USER' | 'EXTERNAL_GROUP' | 'CONDUCTOR_USER' | 'CONDUCTOR_GROUP';
    assignmentPolicy?: (FFAAssignment | Fixed | LeastBusyGroupMemberAssignment);
    claimedBy?: string;
    createdBy?: string;
    createdOn?: number;
    escalatedAt?: number;
    output?: Record<string, Record<string, any>>;
    owners?: Array<string>;
    predefinedInput?: Record<string, Record<string, any>>;
    state?: 'PENDING' | 'ASSIGNED' | 'IN_PROGRESS' | 'COMPLETED' | 'TIMED_OUT';
    taskId?: string;
    taskName?: string;
    taskRefName?: string;
    templateId?: string;
    timeoutPolicy?: (BackToAssigment | ClearAssigment | Escalate | Never | Terminate);
    workflowId?: string;
    workflowName?: string;
};

declare type HTScrollableSearchResultHumanTaskEntry = {
    queryId?: string;
    results?: Array<HumanTaskEntry>;
};

declare type HumanTaskActionLogEntry = {
    action?: string;
    actionTime?: number;
    cause?: string;
    id?: string;
    taskId?: string;
    taskRefName?: string;
    workflowId?: string;
    workflowName?: string;
};

declare type HumanTaskLoad = {
    assignedUser?: string;
    count?: number;
    taskRefName?: string;
    workflowName?: string;
};

declare type HumanTaskStateLogEntry = {
    assignee?: string;
    assigneeType?: 'EXTERNAL_USER' | 'EXTERNAL_GROUP' | 'CONDUCTOR_USER' | 'CONDUCTOR_GROUP';
    claimedBy?: string;
    id?: string;
    state?: 'PENDING' | 'ASSIGNED' | 'IN_PROGRESS' | 'COMPLETED' | 'TIMED_OUT';
    stateEnd?: number;
    stateStart?: number;
    taskId?: string;
    taskRefName?: string;
    workflowId?: string;
    workflowName?: string;
};

declare type HumanTaskTemplate = {
    jsonSchema: Record<string, Record<string, any>>;
    name: string;
    templateUI: Record<string, Record<string, any>>;
    version?: number;
};

declare type HumanTaskTemplateEntry = {
    createdBy?: string;
    createdOn?: number;
    id?: string;
    jsonSchema?: Record<string, Record<string, any>>;
    name?: string;
    templateUI?: Record<string, Record<string, any>>;
    updatedBy?: string;
    updatedOn?: number;
    version?: number;
};

declare type SearchResultHumanTaskEntry = {
    results?: Array<HumanTaskEntry>;
    totalHits?: number;
};

declare class HumanTaskService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * List tasks by filters - task name, state, assignee, assignee type, claimed
     * @param state
     * @param assignee
     * @param assigneeType
     * @param claimedBy
     * @param taskName
     * @param freeText
     * @param includeInputOutput
     * @returns SearchResultHumanTaskEntry OK
     * @throws ApiError
     */
    getTasksByFilter(state: 'PENDING' | 'ASSIGNED' | 'IN_PROGRESS' | 'COMPLETED' | 'TIMED_OUT', assignee?: string, assigneeType?: 'EXTERNAL_USER' | 'EXTERNAL_GROUP' | 'CONDUCTOR_USER' | 'CONDUCTOR_GROUP', claimedBy?: string, taskName?: string, freeText?: string, includeInputOutput?: boolean): CancelablePromise<SearchResultHumanTaskEntry>;
    /**
     * Get task load grouped by workflow name and task ref name per user
     * @returns HumanTaskLoad OK
     * @throws ApiError
     */
    getTaskLoad(): CancelablePromise<Array<HumanTaskLoad>>;
    /**
     * Search human tasks
     * @param queryId
     * @param start
     * @param size
     * @param freeText
     * @param query
     * @param jsonQuery
     * @param includeInputOutput
     * @returns HTScrollableSearchResultHumanTaskEntry OK
     * @throws ApiError
     */
    search1(queryId?: string, start?: number, size?: number, freeText?: string, query?: string, jsonQuery?: string, includeInputOutput?: boolean): CancelablePromise<HTScrollableSearchResultHumanTaskEntry>;
    /**
     * If the workflow is disconnected from tasks, this API can be used to clean up
     * @param taskId
     * @returns any OK
     * @throws ApiError
     */
    updateTaskOutput1(taskId: string): CancelablePromise<any>;
    /**
     * Get a task
     * @param taskId
     * @returns HumanTaskEntry OK
     * @throws ApiError
     */
    getTask1(taskId: string): CancelablePromise<HumanTaskEntry>;
    /**
     * Get human task action log entries by task id
     * @param taskId
     * @returns HumanTaskActionLogEntry OK
     * @throws ApiError
     */
    getActionLogs(taskId: string): CancelablePromise<Array<HumanTaskActionLogEntry>>;
    /**
     * Claim a task by authenticated Conductor user
     * @param taskId
     * @returns any OK
     * @throws ApiError
     */
    claimTask(taskId: string): CancelablePromise<any>;
    /**
     * Claim a task to an external user
     * @param taskId
     * @param userId
     * @returns any OK
     * @throws ApiError
     */
    assignAndClaim(taskId: string, userId: string): CancelablePromise<any>;
    /**
     * Release a task without completing it
     * @param taskId
     * @param requestBody
     * @returns any OK
     * @throws ApiError
     */
    reassignTask(taskId: string, requestBody: (FFAAssignment | Fixed | LeastBusyGroupMemberAssignment)): CancelablePromise<any>;
    /**
     * Release a task without completing it
     * @param taskId
     * @returns any OK
     * @throws ApiError
     */
    releaseTask(taskId: string): CancelablePromise<any>;
    /**
     * Get human task state log entries by task id
     * @param taskId
     * @returns HumanTaskStateLogEntry OK
     * @throws ApiError
     */
    getStateLogs(taskId: string): CancelablePromise<Array<HumanTaskStateLogEntry>>;
    /**
     * Update task output, optionally complete
     * @param taskId
     * @param requestBody
     * @param complete
     * @returns any OK
     * @throws ApiError
     */
    updateTaskOutput(taskId: string, requestBody: Record<string, Record<string, any>>, complete?: boolean): CancelablePromise<any>;
    /**
     * Delete human task templates by name
     * @param name
     * @returns any OK
     * @throws ApiError
     */
    deleteTemplatesByName(name: string): CancelablePromise<any>;
    /**
     * List all human task templates or get templates by name, or a template by name and version
     * @param name
     * @param version
     * @returns HumanTaskTemplateEntry OK
     * @throws ApiError
     */
    getAllTemplates(name?: string, version?: number): CancelablePromise<Array<HumanTaskTemplateEntry>>;
    /**
     * Save human task template
     * @param requestBody
     * @param newVersion
     * @returns string OK
     * @throws ApiError
     */
    saveTemplate(requestBody: HumanTaskTemplate, newVersion?: boolean): CancelablePromise<string>;
    /**
     * Delete human task template
     * @param id
     * @returns any OK
     * @throws ApiError
     */
    deleteTemplateById(id: string): CancelablePromise<any>;
    /**
     * Get human task template by id
     * @param id
     * @returns HumanTaskTemplateEntry OK
     * @throws ApiError
     */
    getTemplateById(id: string): CancelablePromise<HumanTaskTemplateEntry>;
}

declare class HumanTaskResourceService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * Get Conductor task by id (for human tasks only)
     * @param taskId
     * @returns Task OK
     * @throws ApiError
     */
    getConductorTaskById(taskId: string): CancelablePromise<Task>;
}

interface ConductorClientAPIConfig extends Omit<OpenAPIConfig, "BASE"> {
    serverUrl: string;
}
declare class ConductorClient {
    readonly eventResource: EventResourceService;
    readonly healthCheckResource: HealthCheckResourceService;
    readonly metadataResource: MetadataResourceService;
    readonly schedulerResource: SchedulerResourceService;
    readonly taskResource: TaskResourceService;
    readonly tokenResource: TokenResourceService;
    readonly workflowBulkResource: WorkflowBulkResourceService;
    readonly workflowResource: WorkflowResourceService;
    readonly humanTask: HumanTaskService;
    readonly humanTaskResource: HumanTaskResourceService;
    readonly request: BaseHttpRequest;
    token?: string | Resolver<string>;
    constructor(config?: Partial<ConductorClientAPIConfig>, requestHandler?: ConductorHttpRequest);
    stop(): void;
}

declare type ApiResult = {
    readonly url: string;
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
};

declare class ApiError extends Error {
    readonly url: string;
    readonly status: number;
    readonly statusText: string;
    readonly body: any;
    readonly request: ApiRequestOptions;
    constructor(request: ApiRequestOptions, response: ApiResult, message: string);
}

/**
 * Functional interface for defining a worker implementation that processes tasks from a conductor queue.
 *
 * @remarks
 * Optional items allow overriding properties on a per-worker basis. Items not overridden
 * here will be inherited from the `TaskManager` options.
 */
interface ConductorWorker {
    taskDefName: string;
    execute: (task: Task) => Promise<Omit<TaskResult, "workflowInstanceId" | "taskId">>;
    domain?: string;
    concurrency?: number;
    pollInterval?: number;
}

interface ConductorLogger {
    info(...args: any): void;
    error(...args: any): void;
    debug(...args: any): void;
}
declare type ConductorLogLevel = keyof typeof LOG_LEVELS;
interface DefaultLoggerConfig {
    level?: ConductorLogLevel;
    tags?: Object[];
}
declare const LOG_LEVELS: {
    readonly DEBUG: 10;
    readonly INFO: 30;
    readonly ERROR: 60;
};
declare class DefaultLogger implements ConductorLogger {
    private readonly tags;
    private readonly level;
    constructor(config?: DefaultLoggerConfig);
    private log;
    info: (...args: any) => void;
    debug: (...args: any) => void;
    error: (...args: any) => void;
}
declare const noopLogger: ConductorLogger;

interface CommonTaskDef {
    name: string;
    taskReferenceName: string;
}
declare enum TaskType {
    START = "START",
    SIMPLE = "SIMPLE",
    DYNAMIC = "DYNAMIC",
    FORK_JOIN = "FORK_JOIN",
    FORK_JOIN_DYNAMIC = "FORK_JOIN_DYNAMIC",
    DECISION = "DECISION",
    SWITCH = "SWITCH",
    JOIN = "JOIN",
    DO_WHILE = "DO_WHILE",
    SUB_WORKFLOW = "SUB_WORKFLOW",
    EVENT = "EVENT",
    WAIT = "WAIT",
    USER_DEFINED = "USER_DEFINED",
    HTTP = "HTTP",
    LAMBDA = "LAMBDA",
    INLINE = "INLINE",
    EXCLUSIVE_JOIN = "EXCLUSIVE_JOIN",
    TERMINAL = "TERMINAL",
    TERMINATE = "TERMINATE",
    KAFKA_PUBLISH = "KAFKA_PUBLISH",
    JSON_JQ_TRANSFORM = "JSON_JQ_TRANSFORM",
    SET_VARIABLE = "SET_VARIABLE"
}
declare type TaskDefTypes = SimpleTaskDef | DoWhileTaskDef | EventTaskDef | ForkJoinTaskDef | ForkJoinDynamicDef | HttpTaskDef | InlineTaskDef | JsonJQTransformTaskDef | KafkaPublishTaskDef | SetVariableTaskDef | SubWorkflowTaskDef | SwitchTaskDef | TerminateTaskDef | JoinTaskDef | WaitTaskDef;
interface DoWhileTaskDef extends CommonTaskDef {
    inputParameters: Record<string, unknown>;
    type: TaskType.DO_WHILE;
    startDelay?: number;
    optional?: boolean;
    asyncComplete?: boolean;
    loopCondition: string;
    loopOver: TaskDefTypes[];
}
interface EventTaskDef extends CommonTaskDef {
    type: TaskType.EVENT;
    sink: string;
    asyncComplete?: boolean;
}
interface ForkJoinTaskDef extends CommonTaskDef {
    type: TaskType.FORK_JOIN;
    inputParameters?: Record<string, string>;
    forkTasks: Array<Array<TaskDefTypes>>;
}
interface JoinTaskDef extends CommonTaskDef {
    type: TaskType.JOIN;
    inputParameters?: Record<string, string>;
    joinOn: string[];
    optional?: boolean;
    asyncComplete?: boolean;
}
interface ForkJoinDynamicDef extends CommonTaskDef {
    inputParameters: {
        dynamicTasks: any;
        dynamicTasksInput: any;
    };
    type: TaskType.FORK_JOIN_DYNAMIC;
    dynamicForkTasksParam: string;
    dynamicForkTasksInputParamName: string;
    startDelay?: number;
    optional?: boolean;
    asyncComplete?: boolean;
}
interface HttpInputParameters {
    uri: string;
    method: "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD";
    accept?: string;
    contentType?: string;
    headers?: Record<string, string>;
    body?: unknown;
    connectionTimeOut?: number;
    readTimeOut?: string;
}
interface HttpTaskDef extends CommonTaskDef {
    inputParameters: {
        [x: string]: unknown;
        http_request: HttpInputParameters;
    };
    type: TaskType.HTTP;
}
interface InlineTaskInputParameters {
    evaluatorType: "javascript" | "graaljs";
    expression: string;
    [x: string]: unknown;
}
interface InlineTaskDef extends CommonTaskDef {
    type: TaskType.INLINE;
    inputParameters: InlineTaskInputParameters;
}
interface ContainingQueryExpression {
    queryExpression: string;
    [x: string | number | symbol]: unknown;
}
interface JsonJQTransformTaskDef extends CommonTaskDef {
    type: TaskType.JSON_JQ_TRANSFORM;
    inputParameters: ContainingQueryExpression;
}
interface KafkaPublishInputParameters {
    topic: string;
    value: string;
    bootStrapServers: string;
    headers: Record<string, string>;
    key: string;
    keySerializer: string;
}
interface KafkaPublishTaskDef extends CommonTaskDef {
    inputParameters: {
        kafka_request: KafkaPublishInputParameters;
    };
    type: TaskType.KAFKA_PUBLISH;
}
interface SetVariableTaskDef extends CommonTaskDef {
    type: TaskType.SET_VARIABLE;
    inputParameters: Record<string, unknown>;
}
interface SimpleTaskDef extends CommonTaskDef {
    type: TaskType.SIMPLE;
    inputParameters?: Record<string, unknown>;
}
interface SubWorkflowTaskDef extends CommonTaskDef {
    type: TaskType.SUB_WORKFLOW;
    inputParameters?: Record<string, unknown>;
    subWorkflowParam: {
        name: string;
        version?: number;
        taskToDomain?: Record<string, string>;
    };
}
interface SwitchTaskDef extends CommonTaskDef {
    inputParameters: Record<string, unknown>;
    type: TaskType.SWITCH;
    decisionCases: Record<string, TaskDefTypes[]>;
    defaultCase: TaskDefTypes[];
    evaluatorType: "value-param" | "javascript";
    expression: string;
}
interface TerminateTaskDef extends CommonTaskDef {
    inputParameters: {
        terminationStatus: "COMPLETED" | "FAILED";
        workflowOutput?: Record<string, string>;
        terminationReason?: string;
    };
    type: TaskType.TERMINATE;
    startDelay?: number;
    optional?: boolean;
}
interface WaitTaskDef extends CommonTaskDef {
    type: TaskType.WAIT;
    inputParameters: {
        duration?: string;
        until?: string;
    };
}
interface WorkflowDef extends Omit<WorkflowDef$1, "tasks" | "version" | "inputParameters"> {
    inputParameters: string[];
    version: number;
    tasks: TaskDefTypes[];
}

declare type TaskErrorHandler = (error: Error, task?: Task) => void;
interface TaskRunnerOptions {
    workerID: string;
    domain: string | undefined;
    pollInterval?: number;
    concurrency?: number;
    batchPollingTimeout?: number;
}
interface RunnerArgs {
    worker: ConductorWorker;
    taskResource: TaskResourceService;
    options: TaskRunnerOptions;
    logger?: ConductorLogger;
    onError?: TaskErrorHandler;
    concurrency?: number;
}

declare const noopErrorHandler: TaskErrorHandler;
/**
 * Responsible for polling and executing tasks from a queue.
 *
 * Because a `poll` in conductor "pops" a task off of a conductor queue,
 * each runner participates in the poll -> work -> update loop.
 * We could potentially split this work into a separate "poller" and "worker" pools
 * but that could lead to picking up more work than the pool of workers are actually able to handle.
 *
 */
declare class TaskRunner {
    taskResource: TaskResourceService;
    worker: ConductorWorker;
    private logger;
    private options;
    errorHandler: TaskErrorHandler;
    private poller;
    constructor({ worker, taskResource, options, logger, onError: errorHandler, }: RunnerArgs);
    get isPolling(): boolean;
    /**
     * Starts polling for work
     */
    startPolling: () => void;
    /**
     * Stops Polling for work
     */
    stopPolling: () => Promise<void>;
    updateOptions(options: Partial<TaskRunnerOptions>): void;
    get getOptions(): TaskRunnerOptions;
    private batchPoll;
    updateTaskWithRetry: (task: Task, taskResult: TaskResult) => Promise<void>;
    private executeTask;
    handleUnknownError: (unknownError: unknown) => void;
}

declare type TaskManagerOptions = TaskRunnerOptions;
interface TaskManagerConfig {
    logger?: ConductorLogger;
    options?: Partial<TaskManagerOptions>;
    onError?: TaskErrorHandler;
}
/**
 * Responsible for initializing and managing the runners that poll and work different task queues.
 */
declare class TaskManager {
    private workerRunners;
    private readonly client;
    private readonly logger;
    private readonly errorHandler;
    private workers;
    readonly options: Required<TaskManagerOptions>;
    private polling;
    constructor(client: ConductorClient, workers: Array<ConductorWorker>, config?: TaskManagerConfig);
    private workerManagerWorkerOptions;
    get isPolling(): boolean;
    updatePollingOptionForWorker: (workerTaskDefName: string, options: Partial<TaskManagerOptions>) => void;
    /**
     * new options will get merged to existing options
     * @param options new options to update polling options
     */
    updatePollingOptions: (options: Partial<TaskManagerOptions>) => void;
    sanityCheck: () => void;
    /**
     * Start polling for tasks
     */
    startPolling: () => void;
    /**
     * Stops polling for tasks
     */
    stopPolling: () => Promise<void>;
}

declare class ConductorError extends Error {
    private _trace;
    private __proto__;
    constructor(message?: string, innerError?: Error);
}
declare type TaskResultStatus = NonNullable<TaskResult['status']>;

declare class WorkflowExecutor {
    readonly _client: ConductorClient;
    constructor(client: ConductorClient);
    /**
     * Will persist a workflow in conductor
     * @param override If true will override the existing workflow with the definition
     * @param workflow Complete workflow definition
     * @returns null
     */
    registerWorkflow(override: boolean, workflow: WorkflowDef): any;
    /**
     * Takes a StartWorkflowRequest. returns a Promise<string> with the workflowInstanceId of the running workflow
     * @param workflowRequest
     * @returns
     */
    startWorkflow(workflowRequest: StartWorkflowRequest): Promise<string>;
    /**
     * Execute a workflow synchronously. returns a Promise<WorkflowRun> with details of the running workflow
     * @param workflowRequest
     * @returns
     */
    executeWorkflow(workflowRequest: StartWorkflowRequest, name: string, version: number, requestId: string, waitUntilTaskRef?: string): Promise<WorkflowRun>;
    startWorkflows(workflowsRequest: StartWorkflowRequest[]): Promise<string>[];
    /**
     * Takes an workflowInstanceId and an includeTasks and an optional retry parameter returns the whole execution status.
     * If includeTasks flag is provided. Details of tasks execution will be returned as well,
     * retry specifies the amount of retrys before throwing an error.
     *
     * @param workflowInstanceId
     * @param includeTasks
     * @param retry
     * @returns
     */
    getWorkflow(workflowInstanceId: string, includeTasks: boolean, retry?: number): Promise<Workflow>;
    /**
     *  Returns a summary of the current workflow status.
     *
     * @param workflowInstanceId current running workflow
     * @param includeOutput flag to include output
     * @param includeVariables flag to include variable
     * @returns Promise<WorkflowStatus>
     */
    getWorkflowStatus(workflowInstanceId: string, includeOutput: boolean, includeVariables: boolean): Promise<WorkflowStatus>;
    /**
     * Pauses a running workflow
     * @param workflowInstanceId current workflow execution
     * @returns
     */
    pause(workflowInstanceId: string): any;
    /**
     * Reruns workflowInstanceId workflow. with new parameters
     *
     * @param workflowInstanceId current workflow execution
     * @param rerunWorkflowRequest Rerun Workflow Execution Request
     * @returns
     */
    reRun(workflowInstanceId: string, rerunWorkflowRequest?: Partial<RerunWorkflowRequest>): Promise<string>;
    /**
     * Restarts workflow with workflowInstanceId, if useLatestDefinition uses last defintion
     * @param workflowInstanceId
     * @param useLatestDefinitions
     * @returns
     */
    restart(workflowInstanceId: string, useLatestDefinitions: boolean): any;
    /**
     * Resumes a previously paused execution
     *
     * @param workflowInstanceId Running workflow workflowInstanceId
     * @returns
     */
    resume(workflowInstanceId: string): any;
    /**
     * Retrys workflow from last failing task
     * if resumeSubworkflowTasks is true will resume tasks in spawned subworkflows
     *
     * @param workflowInstanceId
     * @param resumeSubworkflowTasks
     * @returns
     */
    retry(workflowInstanceId: string, resumeSubworkflowTasks: boolean): any;
    /**
     * Searches for existing workflows given the following querys
     *
     * @param start
     * @param size
     * @param query
     * @param freeText
     * @param sort
     * @param skipCache
     * @returns
     */
    search(start: number, size: number, query: string, freeText: string, sort?: string, skipCache?: boolean): any;
    /**
     * Skips a task of a running workflow.
     * by providing a skipTaskRequest you can set the input and the output of the skipped tasks
     * @param workflowInstanceId
     * @param taskReferenceName
     * @param skipTaskRequest
     * @returns
     */
    skipTasksFromWorkflow(workflowInstanceId: string, taskReferenceName: string, skipTaskRequest: Partial<SkipTaskRequest>): any;
    /**
     * Takes an workflowInstanceId, and terminates a running workflow
     * @param workflowInstanceId
     * @param reason
     * @returns
     */
    terminate(workflowInstanceId: string, reason: string): any;
    /**
     * Takes a taskId and a workflowInstanceId. Will update the task for the corresponding taskId
     * @param taskId
     * @param workflowInstanceId
     * @param taskStatus
     * @param taskOutput
     * @returns
     */
    updateTask(taskId: string, workflowInstanceId: string, taskStatus: TaskResultStatus, outputData: Record<string, any>): any;
    /**
     * Updates a task by reference Name
     * @param taskReferenceName
     * @param workflowInstanceId
     * @param status
     * @param taskOutput
     * @returns
     */
    updateTaskByRefName(taskReferenceName: string, workflowInstanceId: string, status: TaskResultStatus, taskOutput: Record<string, any>): any;
    /**
     *
     * @param taskId
     * @returns
     */
    getTask(taskId: string): Promise<Task>;
}

declare class HumanExecutor {
    readonly _client: ConductorClient;
    constructor(client: ConductorClient);
    /**
     * Takes a set of filter parameters. return matches of human tasks for that set of parameters
     * @param state
     * @param assignee
     * @param assigneeType
     * @param claimedBy
     * @param taskName
     * @param freeText
     * @param includeInputOutput
     * @returns
     */
    getTasksByFilter(state: "PENDING" | "ASSIGNED" | "IN_PROGRESS" | "COMPLETED" | "TIMED_OUT", assignee?: string, assigneeType?: "EXTERNAL_USER" | "EXTERNAL_GROUP" | "CONDUCTOR_USER" | "CONDUCTOR_GROUP", claimedBy?: string, taskName?: string, freeText?: string, includeInputOutput?: boolean): Promise<HumanTaskEntry[]>;
    /**
     * Returns task for a given task id
     * @param taskId
     * @returns
     */
    getTaskById(taskId: string): Promise<HumanTaskEntry>;
    /**
     * Assigns taskId to assignee. If the task is already assigned to another user, this will fail.
     * @param taskId
     * @param assignee
     * @returns
     */
    claimTaskAsExternalUser(taskId: string, assignee: string): Promise<void>;
    /**
     * Claim task as conductor user
     * @param taskId
     * @returns
     */
    claimTaskAsConductorUser(taskId: string): Promise<void>;
    /**
     * Claim task as conductor user
     * @param taskId
     * @param assignee
     * @returns
     */
    releaseTask(taskId: string): Promise<void>;
    /**
     * Returns a HumanTaskTemplateEntry for a given templateId
     * @param templateId
     * @returns
     */
    getTemplateById(templateId: string): Promise<HumanTaskTemplateEntry>;
    /**
     * Takes a taskId and a partial body. will update with given body
     * @param taskId
     * @param requestBody
     */
    updateTaskOutput(taskId: string, requestBody: Record<string, Record<string, any>>): Promise<void>;
    /**
     * Takes a taskId and an optional partial body. will complete the task with the given body
     * @param taskId
     * @param requestBody
     */
    completeTask(taskId: string, requestBody?: Record<string, Record<string, any>>): Promise<void>;
}

declare const doWhileTask: (taskRefName: string, terminationCondition: string, tasks: TaskDefTypes[]) => DoWhileTaskDef;
declare const newLoopTask: (taskRefName: string, iterations: number, tasks: TaskDefTypes[]) => DoWhileTaskDef;

declare const dynamicForkTask: (taskReferenceName: string, preForkTasks?: TaskDefTypes[], dynamicTasksInput?: string) => ForkJoinDynamicDef;

declare const eventTask: (taskReferenceName: string, eventPrefix: string, eventSuffix: string) => EventTaskDef;
declare const sqsEventTask: (taskReferenceName: string, queueName: string) => EventTaskDef;
declare const conductorEventTask: (taskReferenceName: string, eventName: string) => EventTaskDef;

declare const forkTask: (taskReferenceName: string, forkTasks: TaskDefTypes[]) => ForkJoinTaskDef;
declare const forkTaskJoin: (taskReferenceName: string, forkTasks: TaskDefTypes[]) => [ForkJoinTaskDef, JoinTaskDef];

declare const httpTask: (taskReferenceName: string, inputParameters: HttpInputParameters) => HttpTaskDef;

declare const inlineTask: (taskReferenceName: string, script: string, evaluatorType?: "javascript" | "graaljs") => InlineTaskDef;

declare const joinTask: (taskReferenceName: string, joinOn: string[]) => JoinTaskDef;

declare const jsonJqTask: (taskReferenceName: string, script: string) => JsonJQTransformTaskDef;

declare const kafkaPublishTask: (taskReferenceName: string, kafka_request: KafkaPublishInputParameters) => KafkaPublishTaskDef;

declare const setVariableTask: (taskReferenceName: string, inputParameters: Record<string, unknown>) => SetVariableTaskDef;

declare const simpleTask: (taskReferenceName: string, name: string, inputParameters: Record<string, unknown>) => SimpleTaskDef;

declare const subWorkflowTask: (taskReferenceName: string, workflowName: string, version?: number | undefined) => SubWorkflowTaskDef;

declare const switchTask: (taskReferenceName: string, expression: string, decisionCases?: Record<string, TaskDefTypes[]>, defaultCase?: TaskDefTypes[]) => SwitchTaskDef;

declare const terminateTask: (taskReferenceName: string, status: "COMPLETED" | "FAILED", terminationReason?: string | undefined) => TerminateTaskDef;

declare const waitTaskDuration: (taskReferenceName: string, duration: string) => WaitTaskDef;
declare const waitTaskUntil: (taskReferenceName: string, until: string) => WaitTaskDef;

declare const workflow: (name: string, tasks: TaskDefTypes[]) => WorkflowDef;

/**
 * Takes an optional partial SimpleTaskDef
 * generates a task replacing default values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateSimpleTask: (overrides?: Partial<SimpleTaskDef>) => SimpleTaskDef;

/**
 * Takes an optional partial EventTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateEventTask: (overrides?: Partial<EventTaskDef>) => EventTaskDef;

declare type TaskDefTypesGen = SimpleTaskDef | DoWhileTaskDefGen | EventTaskDef | ForkJoinTaskDefGen | ForkJoinDynamicDef | HttpTaskDef | InlineTaskDefGen | JsonJQTransformTaskDef | KafkaPublishTaskDef | SetVariableTaskDef | SubWorkflowTaskDef | SwitchTaskDefGen | TerminateTaskDef | JoinTaskDef | WaitTaskDef;
interface WorkflowDefGen extends Omit<WorkflowDef, "tasks"> {
    tasks: Partial<TaskDefTypesGen>[];
}
declare type ForkJoinTaskDefGen = Omit<ForkJoinTaskDef, "forkTasks"> & {
    forkTasks: Array<Array<Partial<TaskDefTypesGen>>>;
};
declare type SwitchTaskDefGen = Omit<SwitchTaskDef, "decisionCases" | "defaultCase"> & {
    decisionCases: Record<string, Partial<TaskDefTypesGen>[]>;
    defaultCase: Partial<TaskDefTypesGen>[];
};
declare type DoWhileTaskDefGen = Omit<DoWhileTaskDef, "loopOver"> & {
    loopOver: Partial<TaskDefTypesGen>[];
};
interface InlineTaskInputParametersGen extends Omit<InlineTaskInputParameters, "expression"> {
    expression: string | Function;
}
interface InlineTaskDefGen extends Omit<InlineTaskDef, "inputParameters"> {
    inputParameters: InlineTaskInputParametersGen;
}
declare type NestedTaskMapper = {
    (tasks: Partial<TaskDefTypesGen>[]): TaskDefTypes[];
};

declare const generateJoinTask: (overrides?: Partial<JoinTaskDef>) => JoinTaskDef;

/**
 * Takes an optional partial HttpTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateHTTPTask: (overrides?: Partial<HttpTaskDef>) => HttpTaskDef;

/**
 * Takes an optional partial InlineTaskDefGen
 * generates a task replacing default/fake values with provided overrides
 *
 * <b>note</b> that the inputParameters.expression can be either a string containing javascript
 * or a function thar returns an ES5 function
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateInlineTask: (override?: Partial<InlineTaskDefGen>) => InlineTaskDef;

/**
 * Takes an optional partial JsonJQTransformTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateJQTransformTask: (overrides?: Partial<JsonJQTransformTaskDef>) => JsonJQTransformTaskDef;

/**
 * Takes an optional partial KafkaPublishTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateKafkaPublishTask: (overrides?: Partial<KafkaPublishTaskDef>) => KafkaPublishTaskDef;

/**
 * Takes an optional partial SubWorkflowTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateSubWorkflowTask: (overrides?: Partial<SubWorkflowTaskDef>) => SubWorkflowTaskDef;

/**
 * Takes an optional partial SetVariableTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateSetVariableTask: (overrides?: Partial<SetVariableTaskDef>) => SetVariableTaskDef;

/**
 * Takes an optional partial TerminateTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateTerminateTask: (overrides?: Partial<TerminateTaskDef>) => TerminateTaskDef;

/**
 * Takes an optional partial WaitTaskDef
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generateWaitTask: (overrides?: Partial<WaitTaskDef>) => WaitTaskDef;

declare const taskGenMapper: (tasks: Partial<TaskDefTypesGen>[]) => TaskDefTypes[];
/**
 * Takes an optional partial WorkflowDefGen
 * generates a workflow replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @returns a fully defined task
 */
declare const generate: (overrides: Partial<WorkflowDefGen>) => WorkflowDef;

/**
 * Takes an optional partial SwitchTaskDefGen and an optional nestedMapper
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @param nestedTasksMapper function to run on array of nested tasks
 * @returns a fully defined task
 */
declare const generateSwitchTask: (overrides?: Partial<SwitchTaskDefGen>, nestedTasksMapper?: NestedTaskMapper) => SwitchTaskDef;
/**
 * Takes an optional partial DoWhileTaskDefGen and an optional nestedMapper
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @param nestedTasksMapper function to run on array of nested tasks
 * @returns a fully defined task
 */
declare const generateDoWhileTask: (overrides?: Partial<DoWhileTaskDefGen>, nestedTasksMapper?: NestedTaskMapper) => DoWhileTaskDef;
/**
 * Takes an optional partial DoWhileTaskDefGen and an optional nestedMapper
 * generates a task replacing default/fake values with provided overrides
 *
 * @param overrides overrides for defaults
 * @param nestedTasksMapper function to run on array of nested tasks
 * @returns a fully defined task
 */
declare const generateForkJoinTask: (overrides?: Partial<ForkJoinTaskDefGen>, nestedMapper?: NestedTaskMapper) => ForkJoinTaskDef;

declare type FetchFn<T = RequestInit, R extends {
    json: () => Promise<any>;
} = Response> = (input: RequestInfo, init?: T) => Promise<R>;
declare type OrkesApiConfig = ConductorClientAPIConfig & GenerateTokenRequest;

export { HealthCheckResourceService as $, ApiRequestOptions as A, BaseHttpRequest as B, ConductorHttpRequest as C, StartWorkflow as D, EventHandler as E, FetchFn as F, GenerateTokenRequest as G, StartWorkflowRequest as H, SubWorkflowParams as I, Task as J, TaskDef as K, TaskDetails as L, TaskExecLog as M, TaskResult as N, OrkesApiConfig as O, PollData as P, TaskSummary as Q, RunnerArgs as R, SaveScheduleRequest as S, TaskRunner as T, WorkflowSchedule as U, WorkflowScheduleExecutionModel as V, Workflow as W, WorkflowStatus as X, WorkflowSummary as Y, WorkflowTask as Z, EventResourceService as _, ConductorClient as a, forkTaskJoin as a$, MetadataResourceService as a0, SchedulerResourceService as a1, TaskResourceService as a2, TokenResourceService as a3, WorkflowBulkResourceService as a4, WorkflowResourceService as a5, AssignmentPolicy as a6, Fixed as a7, BackToAssigment as a8, ClearAssigment as a9, JoinTaskDef as aA, ForkJoinDynamicDef as aB, HttpInputParameters as aC, HttpTaskDef as aD, InlineTaskInputParameters as aE, InlineTaskDef as aF, JsonJQTransformTaskDef as aG, KafkaPublishInputParameters as aH, KafkaPublishTaskDef as aI, SetVariableTaskDef as aJ, SimpleTaskDef as aK, SubWorkflowTaskDef as aL, SwitchTaskDef as aM, TerminateTaskDef as aN, WaitTaskDef as aO, WorkflowDef as aP, WorkflowExecutor as aQ, ConductorError as aR, TaskResultStatus as aS, HumanExecutor as aT, doWhileTask as aU, newLoopTask as aV, dynamicForkTask as aW, eventTask as aX, sqsEventTask as aY, conductorEventTask as aZ, forkTask as a_, Escalate as aa, FFAAssignment as ab, HTScrollableSearchResultHumanTaskEntry as ac, HumanTaskActionLogEntry as ad, HumanTaskEntry as ae, HumanTaskLoad as af, HumanTaskStateLogEntry as ag, HumanTaskTemplate as ah, HumanTaskTemplateEntry as ai, LeastBusyGroupMemberAssignment as aj, Never as ak, SearchResultHumanTaskEntry as al, Terminate as am, TimeoutPolicy as an, ConductorLogger as ao, ConductorLogLevel as ap, DefaultLoggerConfig as aq, DefaultLogger as ar, noopLogger as as, RequestType as at, CommonTaskDef as au, TaskType as av, TaskDefTypes as aw, DoWhileTaskDef as ax, EventTaskDef as ay, ForkJoinTaskDef as az, ConductorClientAPIConfig as b, httpTask as b0, inlineTask as b1, joinTask as b2, jsonJqTask as b3, kafkaPublishTask as b4, setVariableTask as b5, simpleTask as b6, subWorkflowTask as b7, switchTask as b8, terminateTask as b9, waitTaskDuration as ba, waitTaskUntil as bb, workflow as bc, generateSimpleTask as bd, generateDoWhileTask as be, generateEventTask as bf, generateForkJoinTask as bg, generateJoinTask as bh, generateHTTPTask as bi, generateInlineTask as bj, generateJQTransformTask as bk, generateKafkaPublishTask as bl, generateSubWorkflowTask as bm, generateSetVariableTask as bn, generateTerminateTask as bo, generateWaitTask as bp, generateSwitchTask as bq, generate as br, taskGenMapper as bs, OpenAPIConfig as c, CancelablePromise as d, TaskManagerOptions as e, TaskManagerConfig as f, TaskManager as g, ConductorWorker as h, TaskErrorHandler as i, TaskRunnerOptions as j, ApiResult as k, OnCancel as l, ApiError as m, noopErrorHandler as n, CancelError as o, Action as p, ExternalStorageLocation as q, RerunWorkflowRequest as r, Response$1 as s, ScrollableSearchResultWorkflowSummary as t, SearchResultTask as u, SearchResultTaskSummary as v, SearchResultWorkflow as w, SearchResultWorkflowScheduleExecutionModel as x, SearchResultWorkflowSummary as y, SkipTaskRequest as z };
